<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>tink — The Loom</title>
<style>
  :root {
    --bg: #0a0a0f;
    --surface: #12121a;
    --border: #1e1e2e;
    --text: #c8c8d8;
    --text-dim: #6e6e8e;
    --accent: #7eb8da;
    --gold: #d4a84e;
    --green: #5cb85c;
    --purple: #9b7ed8;
    --red: #d85c5c;
    --cyan: #5cd8d8;
  }
  * { margin: 0; padding: 0; box-sizing: border-box; }
  body {
    font-family: 'Georgia', 'Times New Roman', serif;
    background: var(--bg);
    color: var(--text);
    line-height: 1.7;
    max-width: 860px;
    margin: 0 auto;
    padding: 1.5rem;
    min-height: 100vh;
  }
  h1, h2, h3 { font-family: 'Segoe UI', system-ui, sans-serif; font-weight: 300; }

  /* Header */
  .header {
    text-align: center;
    padding: 1.5rem 0 1rem;
  }
  .header {
    position: relative;
  }
  .header h1 {
    font-size: 2rem;
    color: var(--accent);
    letter-spacing: 0.08em;
  }
  .sound-toggle {
    position: absolute;
    top: 50%;
    right: 0;
    transform: translateY(-50%);
    background: none;
    border: 1px solid var(--border);
    border-radius: 6px;
    color: var(--text-dim);
    font-size: 1.1rem;
    padding: 0.3rem 0.5rem;
    cursor: pointer;
    transition: border-color 0.2s, color 0.2s;
    line-height: 1;
  }
  .sound-toggle:hover {
    border-color: var(--accent);
    color: var(--text);
  }
  .sound-toggle.muted {
    color: var(--red);
    border-color: var(--red);
    opacity: 0.6;
  }
  .header .subtitle {
    color: var(--text-dim);
    font-size: 0.95rem;
    font-style: italic;
  }

  /* Canvas container */
  .loom-container {
    display: flex;
    justify-content: center;
    margin: 1rem 0;
  }
  canvas {
    border: 1px solid var(--border);
    border-radius: 8px;
    background: var(--surface);
  }

  /* Thread tray */
  .tray-label {
    font-family: 'Segoe UI', system-ui, sans-serif;
    font-size: 1rem;
    color: var(--gold);
    margin: 1.2rem 0 0.6rem;
    padding-bottom: 0.3rem;
    border-bottom: 1px solid var(--border);
  }
  .thread-tray {
    display: flex;
    gap: 0.6rem;
    flex-wrap: wrap;
    margin-bottom: 1rem;
  }
  .thread-card {
    background: var(--surface);
    border: 1px solid var(--border);
    border-radius: 8px;
    padding: 0.7rem 1rem;
    cursor: grab;
    transition: border-color 0.2s, transform 0.15s;
    min-width: 140px;
    flex: 1;
    max-width: 200px;
    touch-action: none;
    user-select: none;
    -webkit-user-select: none;
  }
  .thread-card:hover {
    border-color: var(--accent);
    transform: translateY(-2px);
  }
  .thread-card.selected {
    border-color: var(--gold);
    box-shadow: 0 0 12px rgba(212, 168, 78, 0.2);
  }
  .thread-card .card-name {
    font-family: 'Segoe UI', system-ui, sans-serif;
    font-weight: 600;
    font-size: 0.95rem;
    color: var(--text);
  }
  .thread-card .card-rarity {
    font-family: monospace;
    font-size: 0.7rem;
    text-transform: uppercase;
    letter-spacing: 0.08em;
    margin-left: 0.4rem;
  }
  .rarity-common { color: var(--text-dim); }
  .rarity-uncommon { color: var(--green); }
  .rarity-rare { color: var(--accent); }
  .thread-card .card-traits {
    display: flex;
    flex-wrap: wrap;
    gap: 0.25rem;
    margin-top: 0.4rem;
  }
  .trait-tag {
    font-family: monospace;
    font-size: 0.65rem;
    padding: 0.1rem 0.4rem;
    border-radius: 99px;
    background: rgba(126, 184, 218, 0.1);
    color: var(--cyan);
    border: 1px solid rgba(126, 184, 218, 0.15);
  }

  /* Controls */
  .controls {
    display: flex;
    gap: 0.8rem;
    align-items: center;
    flex-wrap: wrap;
    margin: 0.8rem 0;
  }
  .btn {
    font-family: 'Segoe UI', system-ui, sans-serif;
    font-size: 0.9rem;
    padding: 0.6rem 1.4rem;
    border: 1px solid var(--border);
    border-radius: 6px;
    background: var(--surface);
    color: var(--text);
    cursor: pointer;
    transition: border-color 0.2s, background 0.2s, color 0.2s;
  }
  .btn:hover { border-color: var(--accent); color: var(--accent); }
  .btn-primary {
    background: linear-gradient(135deg, #1a2a3a, #12121a);
    border-color: var(--gold);
    color: var(--gold);
    font-weight: 600;
    font-size: 1rem;
    padding: 0.7rem 2rem;
  }
  .btn-primary:hover {
    background: linear-gradient(135deg, #2a3a4a, #1a1a2a);
    color: #e8c87e;
    border-color: #e8c87e;
  }
  .btn-danger { border-color: var(--red); color: var(--red); }
  .btn-danger:hover { background: rgba(216, 92, 92, 0.1); }
  .hint {
    font-size: 0.8rem;
    color: var(--text-dim);
    font-style: italic;
  }

  /* Results panel */
  .results-panel {
    margin-top: 1.2rem;
  }
  .results-label {
    font-family: 'Segoe UI', system-ui, sans-serif;
    font-size: 1rem;
    color: var(--gold);
    margin-bottom: 0.6rem;
    padding-bottom: 0.3rem;
    border-bottom: 1px solid var(--border);
  }
  .crossing-result {
    background: var(--surface);
    border: 1px solid var(--border);
    border-radius: 8px;
    padding: 0.8rem 1rem;
    margin-bottom: 0.6rem;
  }
  .crossing-header {
    font-family: 'Segoe UI', system-ui, sans-serif;
    font-size: 0.85rem;
    color: var(--text-dim);
    margin-bottom: 0.4rem;
  }
  .crossing-header .thread-name { color: var(--accent); font-weight: 600; }
  .crossing-match {
    display: flex;
    align-items: baseline;
    gap: 0.5rem;
    margin-bottom: 0.3rem;
  }
  .match-name {
    font-family: 'Segoe UI', system-ui, sans-serif;
    font-weight: 600;
    font-size: 1.05rem;
  }
  .match-tier {
    font-family: monospace;
    font-size: 0.7rem;
    text-transform: uppercase;
    letter-spacing: 0.08em;
  }
  .tier-common { color: var(--text-dim); }
  .tier-uncommon { color: var(--green); }
  .tier-rare { color: var(--accent); }
  .tier-mythic { color: var(--purple); }
  .tier-legendary { color: var(--gold); }
  .match-flavor {
    font-style: italic;
    font-size: 0.85rem;
    color: var(--text-dim);
    margin-bottom: 0.3rem;
  }
  .stability-badge {
    font-family: monospace;
    font-size: 0.7rem;
    text-transform: uppercase;
    padding: 0.15rem 0.5rem;
    border-radius: 99px;
    display: inline-block;
  }
  .stability-harmony { background: rgba(125, 186, 125, 0.15); color: #7dba7d; border: 1px solid rgba(125, 186, 125, 0.3); }
  .stability-resonance { background: rgba(125, 125, 186, 0.15); color: #7d7dba; border: 1px solid rgba(125, 125, 186, 0.3); }
  .stability-tension { background: rgba(186, 186, 125, 0.15); color: #baba7d; border: 1px solid rgba(186, 186, 125, 0.3); }
  .stability-paradox { background: rgba(186, 125, 125, 0.15); color: #ba7d7d; border: 1px solid rgba(186, 125, 125, 0.3); }
  .cascade-info {
    font-family: monospace;
    font-size: 0.75rem;
    color: var(--green);
    margin-top: 0.3rem;
  }
  .near-misses {
    margin-top: 0.4rem;
    padding-top: 0.3rem;
    border-top: 1px solid var(--border);
  }
  .near-miss {
    font-family: monospace;
    font-size: 0.7rem;
    color: var(--text-dim);
    opacity: 0.6;
  }
  .near-miss .nm-name { color: var(--text); }
  .no-match {
    font-family: monospace;
    font-size: 0.8rem;
    color: var(--text-dim);
    font-style: italic;
  }

  /* Footer */
  .footer {
    margin-top: 2rem;
    padding-top: 1rem;
    border-top: 1px solid var(--border);
    text-align: center;
    font-size: 0.8rem;
    color: var(--text-dim);
  }
  .footer a { color: var(--text-dim); text-decoration: none; }
  .footer a:hover { color: var(--accent); }

  /* Drag ghost */
  .drag-ghost {
    position: fixed;
    pointer-events: none;
    z-index: 1000;
    opacity: 0.75;
    transform: translate(-50%, -50%) rotate(-2deg) scale(1.05);
    background: var(--surface);
    border: 1px solid var(--gold);
    border-radius: 8px;
    padding: 0.7rem 1rem;
    min-width: 140px;
    max-width: 200px;
    box-shadow: 0 8px 24px rgba(0, 0, 0, 0.5), 0 0 12px rgba(212, 168, 78, 0.2);
  }
  .drag-ghost .card-name {
    font-family: 'Segoe UI', system-ui, sans-serif;
    font-weight: 600;
    font-size: 0.95rem;
    color: var(--text);
  }
  .drag-ghost .card-rarity {
    font-family: monospace;
    font-size: 0.7rem;
    text-transform: uppercase;
    letter-spacing: 0.08em;
    margin-left: 0.4rem;
  }
  .drag-ghost .card-traits {
    display: flex;
    flex-wrap: wrap;
    gap: 0.25rem;
    margin-top: 0.4rem;
  }
  .drag-ghost .trait-tag {
    font-family: monospace;
    font-size: 0.65rem;
    padding: 0.1rem 0.4rem;
    border-radius: 99px;
    background: rgba(126, 184, 218, 0.1);
    border: 1px solid rgba(126, 184, 218, 0.15);
  }
  .thread-card.dragging {
    opacity: 0.3;
    border-style: dashed;
  }

  /* Red flash on rejected drop */
  @keyframes hex-reject-flash {
    0% { opacity: 1; }
    25% { opacity: 0.6; }
    50% { opacity: 1; }
    75% { opacity: 0.6; }
    100% { opacity: 1; }
  }

  /* Activation animation styles */
  .thread-tray.tray-dimmed {
    opacity: 0.3;
    pointer-events: none;
    transform: translateY(8px);
    transition: opacity 0.4s ease, transform 0.4s ease;
  }
  .thread-tray {
    transition: opacity 0.4s ease, transform 0.4s ease;
  }
  .controls .btn.btn-locked {
    opacity: 0.4;
    pointer-events: none;
    cursor: default;
  }

  /* Tension shake */
  @keyframes loom-shake {
    0%, 100% { transform: translateX(0); }
    10% { transform: translateX(-3px); }
    20% { transform: translateX(3px); }
    30% { transform: translateX(-2px); }
    40% { transform: translateX(2px); }
    50% { transform: translateX(-1px); }
    60% { transform: translateX(1px); }
    70% { transform: translateX(0); }
  }
  canvas.shake {
    animation: loom-shake 0.4s ease-in-out;
  }

  /* Paradox vignette overlay */
  .paradox-vignette {
    position: fixed;
    top: 0; left: 0; right: 0; bottom: 0;
    pointer-events: none;
    z-index: 999;
    opacity: 0;
    transition: opacity 0.3s ease;
    background: radial-gradient(ellipse at center, transparent 40%, rgba(216, 92, 92, 0.35) 100%);
  }
  .paradox-vignette.active {
    opacity: 1;
  }

  /* Crossing hover tooltip */
  .crossing-tooltip {
    position: absolute;
    pointer-events: none;
    z-index: 500;
    background: var(--bg);
    border: 1px solid var(--border);
    border-radius: 6px;
    padding: 0.5rem 0.7rem;
    font-family: monospace;
    font-size: 0.75rem;
    line-height: 1.5;
    color: var(--text);
    max-width: 240px;
    opacity: 0;
    transition: opacity 0.15s ease;
    box-shadow: 0 4px 16px rgba(0, 0, 0, 0.5);
  }
  .crossing-tooltip.visible {
    opacity: 1;
  }
  .crossing-tooltip .ct-header {
    font-family: 'Segoe UI', system-ui, sans-serif;
    font-weight: 600;
    font-size: 0.8rem;
    color: var(--accent);
    margin-bottom: 0.25rem;
    padding-bottom: 0.25rem;
    border-bottom: 1px solid var(--border);
  }
  .crossing-tooltip .ct-trait {
    display: flex;
    align-items: center;
    gap: 0.4rem;
    padding: 0.05rem 0;
  }
  .crossing-tooltip .ct-dot {
    width: 6px;
    height: 6px;
    border-radius: 50%;
    flex-shrink: 0;
  }
  .crossing-tooltip .ct-name {
    flex: 1;
  }
  .crossing-tooltip .ct-tag {
    font-size: 0.65rem;
    opacity: 0.6;
  }
  .crossing-tooltip .ct-tag-resonance {
    color: var(--cyan);
    opacity: 1;
  }
  .crossing-tooltip .ct-tag-conflict {
    color: var(--red);
    opacity: 1;
  }
  .crossing-tooltip .ct-stability {
    margin-top: 0.3rem;
    padding-top: 0.25rem;
    border-top: 1px solid var(--border);
    font-size: 0.7rem;
  }

  /* Results fade-in */
  .results-panel.fade-in {
    animation: results-fade 0.5s ease forwards;
  }
  @keyframes results-fade {
    from { opacity: 0; transform: translateY(12px); }
    to { opacity: 1; transform: translateY(0); }
  }

  /* Codex button */
  .codex-btn {
    position: fixed;
    top: 1rem;
    right: 1rem;
    z-index: 1100;
    font-family: 'Segoe UI', system-ui, sans-serif;
    font-size: 0.85rem;
    font-weight: 600;
    padding: 0.5rem 1rem;
    border: 1px solid var(--border);
    border-radius: 6px;
    background: var(--surface);
    color: var(--text-dim);
    cursor: pointer;
    transition: border-color 0.2s, color 0.2s, box-shadow 0.2s;
    letter-spacing: 0.04em;
  }
  .codex-btn:hover {
    border-color: var(--gold);
    color: var(--gold);
    box-shadow: 0 0 8px rgba(212, 168, 78, 0.15);
  }
  .codex-btn .codex-btn-count {
    font-family: monospace;
    font-size: 0.7rem;
    margin-left: 0.4rem;
    opacity: 0.6;
  }
  .codex-btn.discovery-pulse {
    animation: codexPulse 0.6s ease-in-out 3;
  }
  @keyframes codexPulse {
    0%   { box-shadow: 0 0 4px rgba(212, 168, 78, 0.2); transform: scale(1); }
    50%  { box-shadow: 0 0 18px rgba(212, 168, 78, 0.7); transform: scale(1.08); border-color: var(--gold); color: var(--gold); }
    100% { box-shadow: 0 0 4px rgba(212, 168, 78, 0.2); transform: scale(1); }
  }

  /* Codex overlay */
  .codex-overlay {
    display: none;
    position: fixed;
    top: 0; left: 0; right: 0; bottom: 0;
    z-index: 1200;
    background: rgba(5, 5, 10, 0.85);
    overflow-y: auto;
    padding: 2rem 1rem;
  }
  .codex-overlay.open {
    display: flex;
    justify-content: center;
    align-items: flex-start;
  }

  /* Codex panel */
  .codex-panel {
    background: var(--bg);
    border: 1px solid var(--border);
    border-radius: 10px;
    max-width: 620px;
    width: 100%;
    padding: 1.5rem;
    position: relative;
  }
  .codex-panel-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 1rem;
    padding-bottom: 0.8rem;
    border-bottom: 1px solid var(--border);
  }
  .codex-panel-title {
    font-family: 'Segoe UI', system-ui, sans-serif;
    font-size: 1.3rem;
    font-weight: 300;
    color: var(--gold);
    letter-spacing: 0.06em;
  }
  .codex-panel-progress {
    font-family: monospace;
    font-size: 0.8rem;
    color: var(--text-dim);
  }
  .codex-close-btn {
    background: none;
    border: 1px solid var(--border);
    border-radius: 4px;
    color: var(--text-dim);
    font-size: 1.1rem;
    cursor: pointer;
    padding: 0.2rem 0.6rem;
    transition: color 0.2s, border-color 0.2s;
    line-height: 1;
  }
  .codex-close-btn:hover {
    color: var(--red);
    border-color: var(--red);
  }

  /* Codex tier groups */
  .codex-tier-group {
    margin-bottom: 1.2rem;
  }
  .codex-tier-header {
    font-family: 'Segoe UI', system-ui, sans-serif;
    font-size: 0.85rem;
    font-weight: 600;
    text-transform: uppercase;
    letter-spacing: 0.1em;
    padding-bottom: 0.4rem;
    margin-bottom: 0.6rem;
    border-bottom: 1px solid var(--border);
  }
  .codex-tier-header.tier-h-common { color: var(--text-dim); }
  .codex-tier-header.tier-h-uncommon { color: var(--green); }
  .codex-tier-header.tier-h-rare { color: var(--accent); }
  .codex-tier-header.tier-h-mythic { color: var(--purple); }
  .codex-tier-header.tier-h-legendary { color: var(--gold); }
  .codex-tier-count {
    font-weight: 300;
    font-size: 0.75rem;
    opacity: 0.6;
    margin-left: 0.5rem;
  }

  /* Codex entries */
  .codex-entries {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 0.5rem;
  }
  .codex-entry {
    background: var(--surface);
    border: 1px solid var(--border);
    border-radius: 6px;
    padding: 0.6rem 0.8rem;
    transition: border-color 0.2s;
  }
  .codex-entry.discovered {
    border-left: 3px solid;
  }
  .codex-entry.discovered.tier-e-common { border-left-color: var(--text-dim); }
  .codex-entry.discovered.tier-e-uncommon { border-left-color: var(--green); }
  .codex-entry.discovered.tier-e-rare { border-left-color: var(--accent); }
  .codex-entry.discovered.tier-e-mythic { border-left-color: var(--purple); }
  .codex-entry.discovered.tier-e-legendary { border-left-color: var(--gold); }
  .codex-entry.undiscovered {
    border-style: dashed;
    opacity: 0.5;
  }
  .codex-entry-name {
    font-family: 'Segoe UI', system-ui, sans-serif;
    font-weight: 600;
    font-size: 0.9rem;
    color: var(--text);
    margin-bottom: 0.15rem;
  }
  .codex-entry-tier {
    font-family: monospace;
    font-size: 0.65rem;
    text-transform: uppercase;
    letter-spacing: 0.08em;
    margin-left: 0.3rem;
  }
  .codex-entry-flavor {
    font-size: 0.75rem;
    font-style: italic;
    color: var(--text-dim);
    line-height: 1.4;
    margin-bottom: 0.3rem;
  }
  .codex-entry-unknown {
    font-family: monospace;
    font-size: 0.85rem;
    color: var(--text-dim);
    letter-spacing: 0.1em;
  }
  .codex-entry-hint {
    font-size: 0.75rem;
    font-style: italic;
    color: var(--purple);
    opacity: 0.8;
    margin-top: 0.2rem;
  }
  .codex-entry-count {
    font-family: monospace;
    font-size: 0.65rem;
    color: var(--text-dim);
    opacity: 0.5;
    margin-top: 0.2rem;
  }

  /* Codex trait badges */
  .codex-traits {
    display: flex;
    flex-wrap: wrap;
    gap: 0.2rem;
    margin-top: 0.3rem;
  }
  .codex-trait-badge {
    font-family: monospace;
    font-size: 0.6rem;
    padding: 0.08rem 0.35rem;
    border-radius: 99px;
    border: 1px solid;
    line-height: 1.4;
  }

  /* Wander phase UI */
  .wander-hud {
    display: none;
    text-align: center;
    margin: 0.8rem 0;
  }
  .wander-hud.active {
    display: block;
  }
  .satchel-counter {
    font-family: 'Segoe UI', system-ui, sans-serif;
    font-size: 1rem;
    color: var(--gold);
    letter-spacing: 0.04em;
  }
  .satchel-counter .satchel-count {
    font-family: monospace;
    font-size: 0.85rem;
    color: var(--text-dim);
    margin-left: 0.3rem;
  }

  /* Thread draft overlay */
  .thread-draft-overlay {
    display: none;
    position: fixed;
    top: 0; left: 0; right: 0; bottom: 0;
    z-index: 1200;
    background: rgba(5, 5, 10, 0.85);
    overflow-y: auto;
    padding: 2rem 1rem;
  }
  .thread-draft-overlay.open {
    display: flex;
    justify-content: center;
    align-items: center;
  }
  .thread-draft-panel {
    background: var(--bg);
    border: 1px solid var(--border);
    border-radius: 10px;
    max-width: 520px;
    width: 100%;
    padding: 1.5rem;
  }
  .thread-draft-title {
    font-family: 'Segoe UI', system-ui, sans-serif;
    font-size: 1.1rem;
    color: var(--gold);
    margin-bottom: 0.4rem;
    font-weight: 300;
  }
  .thread-draft-subtitle {
    font-size: 0.8rem;
    color: var(--text-dim);
    margin-bottom: 1rem;
    font-style: italic;
  }
  .thread-draft-cards {
    display: flex;
    gap: 0.6rem;
    flex-wrap: wrap;
    margin-bottom: 1rem;
  }
  .thread-draft-card {
    background: var(--surface);
    border: 1px solid var(--border);
    border-radius: 8px;
    padding: 0.8rem 1rem;
    cursor: pointer;
    transition: border-color 0.2s, transform 0.15s, box-shadow 0.2s;
    flex: 1;
    min-width: 140px;
  }
  .thread-draft-card:hover {
    border-color: var(--accent);
    transform: translateY(-2px);
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
  }
  .thread-draft-card .draft-card-name {
    font-family: 'Segoe UI', system-ui, sans-serif;
    font-weight: 600;
    font-size: 0.95rem;
    color: var(--text);
  }
  .thread-draft-card .rarity-badge {
    font-family: monospace;
    font-size: 0.7rem;
    text-transform: uppercase;
    letter-spacing: 0.08em;
    margin-left: 0.4rem;
  }
  .rarity-badge.rarity-common { color: var(--text-dim); }
  .rarity-badge.rarity-uncommon { color: var(--green); }
  .rarity-badge.rarity-rare { color: var(--accent); }
  .thread-draft-card .nature-traits {
    display: flex;
    flex-wrap: wrap;
    gap: 0.25rem;
    margin-top: 0.4rem;
  }
  .thread-draft-card .nature-traits .trait-tag {
    font-family: monospace;
    font-size: 0.65rem;
    padding: 0.1rem 0.4rem;
    border-radius: 99px;
    background: rgba(126, 184, 218, 0.1);
    color: var(--cyan);
    border: 1px solid rgba(126, 184, 218, 0.15);
  }
  .thread-draft-card.satchel-full-card {
    opacity: 0.5;
    cursor: default;
    border-color: var(--border);
  }
  .thread-draft-card.satchel-full-card:hover {
    transform: none;
    border-color: var(--border);
    box-shadow: none;
  }
  .thread-draft-skip {
    display: inline-block;
    font-family: 'Segoe UI', system-ui, sans-serif;
    font-size: 0.85rem;
    color: var(--text-dim);
    cursor: pointer;
    padding: 0.4rem 1rem;
    border: 1px solid var(--border);
    border-radius: 6px;
    background: transparent;
    transition: color 0.2s, border-color 0.2s;
  }
  .thread-draft-skip:hover {
    color: var(--text);
    border-color: var(--text-dim);
  }
  .satchel-full-notice {
    font-family: 'Segoe UI', system-ui, sans-serif;
    font-size: 0.9rem;
    color: var(--gold);
    text-align: center;
    padding: 1rem;
    font-style: italic;
  }

  /* Satchel contents in wander HUD */
  .satchel-contents {
    margin-top: 0.5rem;
    display: flex;
    flex-wrap: wrap;
    gap: 0.3rem;
    justify-content: center;
  }
  .satchel-contents .satchel-thread {
    font-family: monospace;
    font-size: 0.7rem;
    padding: 0.1rem 0.5rem;
    border-radius: 99px;
    background: rgba(126, 184, 218, 0.08);
    border: 1px solid rgba(126, 184, 218, 0.15);
  }
  .satchel-thread.rarity-common { color: var(--text-dim); border-color: rgba(110, 110, 142, 0.25); }
  .satchel-thread.rarity-uncommon { color: var(--green); border-color: rgba(92, 184, 92, 0.25); }
  .satchel-thread.rarity-rare { color: var(--accent); border-color: rgba(126, 184, 218, 0.25); }

  /* Shrine overlay */
  .shrine-overlay {
    display: none;
    position: fixed;
    top: 0; left: 0; right: 0; bottom: 0;
    z-index: 1200;
    background: rgba(5, 5, 15, 0.88);
    overflow-y: auto;
    padding: 2rem 1rem;
  }
  .shrine-overlay.open {
    display: flex;
    justify-content: center;
    align-items: center;
  }
  .shrine-panel {
    background: var(--bg);
    border: 1px solid var(--purple);
    border-radius: 10px;
    max-width: 440px;
    width: 100%;
    padding: 1.8rem;
    box-shadow: 0 0 30px rgba(155, 126, 216, 0.15);
    text-align: center;
  }
  .shrine-title {
    font-family: 'Segoe UI', system-ui, sans-serif;
    font-size: 1.15rem;
    color: var(--purple);
    margin-bottom: 1rem;
    font-weight: 300;
    letter-spacing: 0.06em;
  }
  .shrine-clue-text {
    font-size: 1rem;
    font-style: italic;
    color: var(--text);
    line-height: 1.6;
    margin-bottom: 1rem;
    padding: 0.6rem 0;
  }
  .shrine-archetype-name {
    font-family: 'Segoe UI', system-ui, sans-serif;
    font-size: 0.8rem;
    color: var(--text-dim);
    margin-bottom: 1.2rem;
    letter-spacing: 0.04em;
  }
  .shrine-archetype-name em {
    color: var(--purple);
    font-style: normal;
    font-weight: 600;
  }
  .shrine-dismiss {
    display: inline-block;
    font-family: 'Segoe UI', system-ui, sans-serif;
    font-size: 0.85rem;
    color: var(--purple);
    cursor: pointer;
    padding: 0.5rem 1.4rem;
    border: 1px solid var(--purple);
    border-radius: 6px;
    background: transparent;
    transition: color 0.2s, border-color 0.2s, background 0.2s;
  }
  .shrine-dismiss:hover {
    background: rgba(155, 126, 216, 0.1);
    color: #b99ef0;
    border-color: #b99ef0;
  }
  .shrine-silent {
    font-size: 0.9rem;
    color: var(--text-dim);
    font-style: italic;
    padding: 0.6rem 0;
    margin-bottom: 1rem;
  }

  /* Return to loom button */
  .return-loom-btn {
    display: inline-block;
    font-family: 'Segoe UI', system-ui, sans-serif;
    font-size: 0.85rem;
    padding: 0.5rem 1.2rem;
    border: 1px solid var(--gold);
    border-radius: 6px;
    background: linear-gradient(135deg, #1a2a3a, #12121a);
    color: var(--gold);
    cursor: pointer;
    transition: background 0.2s, color 0.2s, border-color 0.2s;
    margin-top: 0.6rem;
  }
  .return-loom-btn:hover {
    background: linear-gradient(135deg, #2a3a4a, #1a1a2a);
    color: #e8c87e;
    border-color: #e8c87e;
  }

  /* Cycle indicator */
  .cycle-indicator {
    font-family: monospace;
    font-size: 0.75rem;
    color: var(--text-dim);
    letter-spacing: 0.08em;
    text-transform: uppercase;
    margin-top: 0.3rem;
  }
  .cycle-indicator .cycle-current {
    color: var(--gold);
    font-weight: 600;
  }

  /* Run summary overlay */
  .run-summary-overlay {
    position: fixed;
    inset: 0;
    background: rgba(10, 10, 15, 0.9);
    z-index: 800;
    display: flex;
    align-items: center;
    justify-content: center;
    opacity: 0;
    transition: opacity 0.4s;
    pointer-events: none;
  }
  .run-summary-overlay.open {
    opacity: 1;
    pointer-events: auto;
  }
  .run-summary-panel {
    background: var(--surface);
    border: 1px solid var(--gold);
    border-radius: 12px;
    padding: 2rem 2.5rem;
    max-width: 500px;
    width: 90%;
    text-align: center;
  }
  .run-summary-panel h2 {
    color: var(--gold);
    font-size: 1.4rem;
    margin-bottom: 1rem;
  }
  .run-summary-stat {
    font-family: monospace;
    font-size: 0.85rem;
    color: var(--text);
    margin: 0.5rem 0;
  }
  .run-summary-stat .stat-value {
    color: var(--accent);
    font-weight: 600;
  }
  .run-summary-actions {
    margin-top: 1.5rem;
    display: flex;
    gap: 0.8rem;
    justify-content: center;
  }

  /* Results cycle header */
  .results-cycle-header {
    font-family: monospace;
    font-size: 0.8rem;
    color: var(--gold);
    text-transform: uppercase;
    letter-spacing: 0.06em;
    margin-bottom: 0.6rem;
    text-align: center;
  }
  .results-run-progress {
    font-family: monospace;
    font-size: 0.7rem;
    color: var(--text-dim);
    text-align: center;
    margin-top: 0.6rem;
    padding-top: 0.4rem;
    border-top: 1px solid var(--border);
  }
  .results-actions {
    display: flex;
    gap: 0.8rem;
    justify-content: center;
    margin-top: 0.8rem;
  }

  @media (max-width: 500px) {
    .codex-entries { grid-template-columns: 1fr; }
    .codex-panel { padding: 1rem; }
  }
</style>
</head>
<body>

<div class="header">
  <h1>tink</h1>
  <div class="subtitle">The Loom</div>
  <div class="cycle-indicator" id="cycleIndicator" style="display: none;"></div>
  <button class="sound-toggle" id="soundToggle" title="Toggle sound">&#x1f50a;</button>
</div>

<div class="loom-container" style="position: relative;">
  <canvas id="loomCanvas" width="600" height="560"></canvas>
  <div class="crossing-tooltip" id="crossingTooltip"></div>
</div>

<h2 class="tray-label">Thread Tray</h2>
<div class="thread-tray" id="threadTray"></div>

<div class="wander-hud" id="wanderHud">
  <span class="satchel-counter">Satchel <span class="satchel-count" id="satchelCount">0 / 6</span></span>
  <div class="satchel-contents" id="satchelContents"></div>
  <button class="return-loom-btn" id="returnLoomBtn">Return to Loom</button>
</div>

<div class="controls" id="weaveControls">
  <button class="btn btn-primary" id="activateBtn">Pull the Lever</button>
  <button class="btn btn-danger" id="resetBtn">Reset Loom</button>
  <button class="btn" id="wanderBtn">Wander</button>
  <span class="hint" id="hintText">Click a thread, then click an empty hex to place it.</span>
</div>

<button class="codex-btn" id="codexBtn">Codex <span class="codex-btn-count" id="codexBtnCount"></span></button>
<div class="codex-overlay" id="codexOverlay">
  <div class="codex-panel" id="codexPanel"></div>
</div>

<div class="thread-draft-overlay" id="threadDraftOverlay">
  <div class="thread-draft-panel" id="threadDraftPanel"></div>
</div>

<div class="shrine-overlay" id="shrineOverlay">
  <div class="shrine-panel" id="shrinePanel"></div>
</div>

<div class="results-panel" id="resultsPanel" style="display: none;">
  <h2 class="results-label">Crossing Results</h2>
  <div id="resultsContent"></div>
</div>

<div class="run-summary-overlay" id="runSummaryOverlay">
  <div class="run-summary-panel" id="runSummaryPanel"></div>
</div>

<div class="paradox-vignette" id="paradoxVignette"></div>

<div class="footer">
  <a href="index.html">back to project page</a>
</div>

<script>
// ============================================================
// ENGINE: unify.js
// ============================================================

function unify(a, b) {
  const allKeys = new Set([...Object.keys(a), ...Object.keys(b)]);
  const sharedKeys = Object.keys(a).filter((k) => k in b);

  const unified = {};
  const conflicts = [];
  const resonances = [];

  for (const key of allKeys) {
    const inA = key in a;
    const inB = key in b;

    if (inA && inB) {
      const va = a[key];
      const vb = b[key];

      if (va === vb) {
        unified[key] = va;
        resonances.push(key);
      } else if (typeof va === "number" && typeof vb === "number") {
        if ((va > 0 && vb > 0) || (va < 0 && vb < 0) || va === 0 || vb === 0) {
          unified[key] = va + vb;
        } else {
          unified[key] = { conflicted: true, from: [va, vb] };
          conflicts.push(key);
        }
      } else {
        unified[key] = { conflicted: true, from: [va, vb] };
        conflicts.push(key);
      }
    } else {
      unified[key] = inA ? a[key] : b[key];
    }
  }

  let stability;
  if (sharedKeys.length === 0) {
    stability = "harmony";
  } else if (conflicts.length === 0) {
    stability = "resonance";
  } else if (conflicts.length >= 2 && conflicts.length / sharedKeys.length > 0.5) {
    stability = "paradox";
  } else {
    stability = "tension";
  }

  return { unified, stability, conflicts, resonances };
}

function flattenUnified(unified) {
  const flat = {};
  for (const [k, v] of Object.entries(unified)) {
    if (v && typeof v === "object" && v.conflicted) {
      flat[k] = "conflicted";
    } else {
      flat[k] = v;
    }
  }
  return flat;
}

// ============================================================
// ENGINE: archetypes.js
// ============================================================

const CATALOG = [
  // --- Natural phenomena ---
  {
    name: "Aurora",
    required: { bright: true, cold: true },
    tier: "uncommon",
    flavor: "Light bends through frozen air, painting impossible colors.",
    cascade: { cold: true, bright: true },
  },
  {
    name: "Stormglass",
    required: { volatile: true, bright: true, liquid: true },
    tier: "rare",
    flavor: "A vessel of contained lightning, swirling and alive.",
    cascade: { volatile: true, liquid: true },
  },
  {
    name: "Permafrost",
    required: { cold: true, persistent: true, vast: true },
    tier: "uncommon",
    flavor: "What freezes deep enough never thaws.",
    cascade: { cold: true, persistent: true },
  },
  {
    name: "Wildfire",
    required: { hot: true, volatile: true, organic: true },
    tier: "uncommon",
    flavor: "It doesn't burn the forest. It becomes the forest.",
    cascade: { hot: true, ephemeral: true },
  },

  // --- Emotional constructs ---
  {
    name: "Vendetta Engine",
    required: { emotional: true, mechanical: true, persistent: true },
    tier: "rare",
    flavor: "A grudge so precise it runs on clockwork.",
    cascade: { persistent: true, sharp: true },
  },
  {
    name: "Euphoria Cascade",
    required: { emotional: true, bright: true, volatile: true },
    tier: "uncommon",
    flavor: "Joy so intense it becomes unstable.",
    cascade: { bright: true, ephemeral: true },
  },
  {
    name: "Quiet Resolve",
    required: { emotional: true, persistent: true, calm: true },
    tier: "common",
    flavor: "Not loud. Not fast. But absolutely certain.",
    cascade: { calm: true },
  },
  {
    name: "Heartstring",
    required: { emotional: true, organic: true },
    tier: "common",
    flavor: "A connection that pulses with something warm.",
    cascade: { organic: true },
  },

  // --- Mythological archetypes ---
  {
    name: "Web of Wyrd",
    required: { persistent: true, vast: true, sharp: true },
    tier: "rare",
    flavor: "Fate is not a line. It is a net, and every knot remembers.",
    cascade: { persistent: true, vast: true },
  },
  {
    name: "Anansi's Thread",
    required: { sharp: true, organic: true, ephemeral: true },
    tier: "rare",
    flavor: "The trickster's gift: a story that catches you before you catch it.",
    cascade: { sharp: true, ephemeral: true },
  },
  {
    name: "Bifrost Shard",
    required: { bright: true, vast: true, cold: true },
    tier: "rare",
    flavor: "A fragment of the bridge between worlds, still humming.",
    cascade: { bright: true, vast: true },
  },

  // --- Inventions ---
  {
    name: "Perpetual Motion",
    required: { mechanical: true, persistent: true },
    tier: "uncommon",
    flavor: "It shouldn't work. It does. Don't ask why.",
    cascade: { mechanical: true },
  },
  {
    name: "Resonance Crystal",
    required: { bright: true, sharp: true, mechanical: true },
    tier: "uncommon",
    flavor: "Cut to a frequency that makes other things vibrate in sympathy.",
    cascade: { bright: true, sharp: true },
  },
  {
    name: "Living Clockwork",
    required: { mechanical: true, organic: true, persistent: true },
    tier: "rare",
    flavor: "Gears that grow. Springs that breathe. Ticking that sounds like a heartbeat.",
    cascade: { organic: true, mechanical: true },
  },

  // --- Paradox archetypes (require conflict) ---
  {
    name: "Paradox Bloom",
    required: { _minConflicts: 3 },
    tier: "mythic",
    flavor: "A flower that exists in the space between contradictions. It is beautiful and it should not be.",
    cascade: { volatile: true, organic: true, emotional: true },
  },
  {
    name: "Schrodinger's Thread",
    required: { _minConflicts: 2, mechanical: true },
    tier: "rare",
    flavor: "Simultaneously wound and unwound until observed.",
    cascade: { mechanical: true, ephemeral: true },
  },
  {
    name: "Oxymoron Engine",
    required: { _minConflicts: 2, persistent: true },
    tier: "rare",
    flavor: "Runs on impossibility. The more it contradicts, the harder it works.",
    cascade: { persistent: true, volatile: true },
  },

  // --- Abstract ---
  {
    name: "Echo Chamber",
    required: { vast: true, ephemeral: true },
    tier: "common",
    flavor: "A space where whispers return louder than they left.",
    cascade: { vast: true },
  },
  {
    name: "Void Lens",
    required: { vast: true, sharp: true, cold: true },
    tier: "rare",
    flavor: "Focuses emptiness until it cuts.",
    cascade: { cold: true, sharp: true },
  },

  // --- Legendary (cascade-only) ---
  {
    name: "Tapestry of Ages",
    required: { persistent: true, vast: true, emotional: true, bright: true, organic: true },
    cascade: { persistent: true, vast: true, calm: true },
    tier: "legendary",
    flavor: "Every thread that ever was, remembered in a single weave.",
  },
  {
    name: "Paradox Engine",
    required: { _minConflicts: 3, mechanical: true, persistent: true, volatile: true, emotional: true },
    cascade: { volatile: true, mechanical: true, sharp: true },
    tier: "legendary",
    flavor: "It runs on impossibility. Each contradiction powers the next.",
  },
  {
    name: "The Unraveling",
    required: { ephemeral: true, vast: true, sharp: true, volatile: true, emotional: true },
    cascade: { ephemeral: true, volatile: true },
    tier: "legendary",
    flavor: "Not destruction. Transformation so fast it looks like ending.",
  },
];

function matchArchetype(unificationResult) {
  const { unified, conflicts } = unificationResult;
  const flat = flattenUnified(unified);
  const candidates = [];

  for (const archetype of CATALOG) {
    const score = scoreMatch(flat, archetype, conflicts);
    if (score.ratio >= 0.5) {
      candidates.push({ ...archetype, ...score });
    }
  }

  const tierOrder = { legendary: -1, mythic: 0, rare: 1, uncommon: 2, common: 3 };
  candidates.sort((a, b) => {
    if (b.score !== a.score) return b.score - a.score;
    return (tierOrder[a.tier] ?? 4) - (tierOrder[b.tier] ?? 4);
  });

  const best = candidates[0] || null;

  const nearMisses = candidates
    .filter((c) => c !== best && c.ratio >= 0.5 && c.ratio < 1.0)
    .map((c) => ({
      name: c.name,
      tier: c.tier,
      matched: c.matched,
      total: c.total,
      ratio: c.ratio,
      missingTraits: Object.keys(c.required)
        .filter((k) => k !== "_minConflicts" && !(k in flat && flat[k] === c.required[k])),
    }))
    .slice(0, 3);

  return {
    match: best ? { name: best.name, tier: best.tier, flavor: best.flavor, cascade: best.cascade || {} } : null,
    score: best ? { matched: best.matched, total: best.total, ratio: best.ratio, score: best.score } : null,
    candidates: candidates.map((c) => ({
      name: c.name,
      tier: c.tier,
      matched: c.matched,
      total: c.total,
      ratio: c.ratio,
      score: c.score,
    })),
    nearMisses,
  };
}

function scoreMatch(flat, archetype, conflicts) {
  const req = archetype.required;
  let matched = 0;
  let total = 0;

  for (const [key, val] of Object.entries(req)) {
    if (key === "_minConflicts") {
      total++;
      if (conflicts.length >= val) matched++;
      continue;
    }
    total++;
    if (key in flat && flat[key] === val) {
      matched++;
    }
  }

  const ratio = total > 0 ? matched / total : 0;
  const score = matched * (1 + ratio * 0.1);
  return { matched, total, ratio, score };
}

function getCatalog() {
  return CATALOG;
}

// ============================================================
// ENGINE: threads.js
// ============================================================

const THREADS = [
  // --- Physical (common) ---
  { name: "Ember", nature: { hot: true, bright: true, ephemeral: true }, rarity: "common", flavor: "A spark remembering the fire it came from." },
  { name: "Glacier", nature: { cold: true, vast: true, persistent: true }, rarity: "common", flavor: "Patience measured in millennia." },
  { name: "Clockwork", nature: { mechanical: true, persistent: true, sharp: true }, rarity: "common", flavor: "Every tooth knows its neighbor." },
  { name: "Tidepool", nature: { liquid: true, organic: true, calm: true }, rarity: "common", flavor: "A small world, complete." },
  { name: "Obsidian", nature: { sharp: true, cold: true, persistent: true }, rarity: "common", flavor: "Glass born from violence, cooled into patience." },
  { name: "Pollen", nature: { organic: true, ephemeral: true, bright: true }, rarity: "common", flavor: "Carries futures on the wind." },
  { name: "Lodestone", nature: { mechanical: true, persistent: true }, rarity: "common", flavor: "It points. It always points." },
  { name: "Dewdrop", nature: { liquid: true, bright: true, ephemeral: true }, rarity: "common", flavor: "A lens that lasts until the sun finds it." },
  { name: "Granite", nature: { vast: true, persistent: true, calm: true }, rarity: "common", flavor: "The mountain does not argue." },
  { name: "Spark", nature: { hot: true, volatile: true, ephemeral: true }, rarity: "common", flavor: "A beginning that doesn't know it yet." },

  // --- Emotional (uncommon) ---
  { name: "Grudge", nature: { emotional: true, persistent: true, hot: true }, rarity: "uncommon", flavor: "It remembers everything. Forgives nothing." },
  { name: "Joy", nature: { emotional: true, bright: true, volatile: true }, rarity: "uncommon", flavor: "Difficult to hold. Impossible to fake." },
  { name: "Doubt", nature: { emotional: true, cold: true, sharp: true }, rarity: "uncommon", flavor: "The blade you sharpen against yourself." },
  { name: "Nostalgia", nature: { emotional: true, ephemeral: true, calm: true }, rarity: "uncommon", flavor: "The past, edited for your comfort." },
  { name: "Fury", nature: { emotional: true, hot: true, volatile: true }, rarity: "uncommon", flavor: "Burns clean. Burns everything." },
  { name: "Awe", nature: { emotional: true, vast: true, bright: true }, rarity: "uncommon", flavor: "The feeling of smallness that makes you larger." },
  { name: "Dread", nature: { emotional: true, cold: true, persistent: true, vast: true }, rarity: "uncommon", flavor: "The weight of a future you can already see." },
  { name: "Whimsy", nature: { emotional: true, volatile: true, bright: true, organic: true }, rarity: "uncommon", flavor: "Rules? What rules?" },
  { name: "Patience", nature: { emotional: true, persistent: true, calm: true }, rarity: "uncommon", flavor: "Not waiting. Choosing when." },
  { name: "Spite", nature: { emotional: true, sharp: true, hot: true, persistent: true }, rarity: "uncommon", flavor: "Revenge's quieter, more efficient sibling." },

  // --- Abstract (rare) ---
  { name: "Paradox", nature: { volatile: true, persistent: true, hot: true, cold: true }, rarity: "rare", flavor: "It insists on being two things at once." },
  { name: "Echo", nature: { ephemeral: true, vast: true, mechanical: true }, rarity: "rare", flavor: "A shape left by something that already passed." },
  { name: "Silence", nature: { calm: true, vast: true, cold: true }, rarity: "rare", flavor: "Not the absence of sound. The presence of nothing." },
  { name: "Catalyst", nature: { volatile: true, sharp: true, organic: true }, rarity: "rare", flavor: "Unchanged by the change it causes." },
  { name: "Recursion", nature: { mechanical: true, persistent: true, vast: true }, rarity: "rare", flavor: "It contains itself, which contains itself, which--" },
  { name: "Mirage", nature: { bright: true, hot: true, vast: true, ephemeral: true }, rarity: "rare", flavor: "Real enough to walk toward. Gone when you arrive." },
  { name: "Entropy", nature: { vast: true, persistent: true, cold: true, volatile: true }, rarity: "rare", flavor: "Everything falls apart. This is how." },
  { name: "Anima", nature: { organic: true, emotional: true, bright: true, persistent: true }, rarity: "rare", flavor: "The part that makes the rest alive." },
  { name: "Void", nature: { vast: true, cold: true, calm: true, persistent: true }, rarity: "rare", flavor: "Not empty. Full of nothing." },
  { name: "Ouroboros", nature: { organic: true, mechanical: true, persistent: true, volatile: true }, rarity: "rare", flavor: "The end that is the beginning that is the end." },
];

function getAllThreads() {
  return THREADS;
}

function randomThreads(count) {
  const shuffled = [...THREADS].sort(() => Math.random() - 0.5);
  return shuffled.slice(0, count);
}

function getByRarity(rarity) {
  return THREADS.filter((t) => t.rarity === rarity);
}

// ============================================================
// ENGINE: loom.js
// ============================================================

// Ring 1: 6 neighbors at distance 1
const RING_1 = [
  { q: 1, r: 0 },   // east
  { q: 0, r: 1 },   // southeast
  { q: -1, r: 1 },  // southwest
  { q: -1, r: 0 },  // west
  { q: 0, r: -1 },  // northwest
  { q: 1, r: -1 },  // northeast
];

// Ring 2: 12 cells at distance 2
const RING_2 = [
  { q: 2, r: 0 },   { q: 2, r: -1 },  { q: 2, r: -2 },
  { q: 1, r: -2 },  { q: 0, r: -2 },  { q: -1, r: -1 },
  { q: -2, r: 0 },  { q: -2, r: 1 },  { q: -2, r: 2 },
  { q: -1, r: 2 },  { q: 0, r: 2 },   { q: 1, r: 1 },
];

// Partial ring 2: 5 cells for the "large" tier
const RING_2_PARTIAL = [
  { q: 2, r: -1 },  { q: 0, r: -2 },  { q: -2, r: 1 },
  { q: -1, r: 2 },  { q: 1, r: 1 },
];

const LOOM_TIERS = {
  small: {
    positions: [
      { q: 0, r: 0 },
      { q: 1, r: 0 },
      { q: 0, r: 1 },
    ],
    label: "Apprentice Loom",
  },
  medium: {
    positions: [
      { q: 0, r: 0 },
      ...RING_1,
    ],
    label: "Journeyman Loom",
  },
  large: {
    positions: [
      { q: 0, r: 0 },
      ...RING_1,
      ...RING_2_PARTIAL,
    ],
    label: "Master Loom",
  },
  full: {
    positions: [
      { q: 0, r: 0 },
      ...RING_1,
      ...RING_2,
    ],
    label: "Grand Loom",
  },
};

// Legacy alias — kept so static getter Loom.POSITIONS still works
const HEX_POSITIONS = LOOM_TIERS.medium.positions;

// Dynamic tier tracking for the current game session
let currentLoomTier = "small";
function getHexPositions() { return LOOM_TIERS[currentLoomTier].positions; }
function getLoomLabel() { return LOOM_TIERS[currentLoomTier].label; }

// Determine loom tier based on codex discoveries
function computeLoomTier() {
  const n = typeof codexData !== "undefined" ? Object.keys(codexData.discovered).length : 0;
  if (n >= 15) return "full";
  if (n >= 10) return "large";
  if (n >= 5)  return "medium";
  return "small";
}

// Check for loom expansion and apply if tier changed
function checkLoomExpansion() {
  const newTier = computeLoomTier();
  if (newTier !== currentLoomTier) {
    const oldTier = currentLoomTier;
    currentLoomTier = newTier;
    loom.upgradeTier(newTier);
    showLoomExpandedMessage(oldTier, newTier);
    drawLoom();
    return true;
  }
  return false;
}

// Brief overlay message when loom grows
function showLoomExpandedMessage(oldTier, newTier) {
  const label = LOOM_TIERS[newTier].label;
  const count = LOOM_TIERS[newTier].positions.length;
  const msg = document.createElement("div");
  msg.textContent = "Loom Expanded! " + label + " (" + count + " cells)";
  msg.style.cssText = "position:fixed;top:30%;left:50%;transform:translate(-50%,-50%);" +
    "color:#d4a84e;font:bold 18px Georgia,serif;text-align:center;" +
    "background:rgba(12,12,18,0.85);padding:12px 28px;border:1px solid #d4a84e;" +
    "border-radius:8px;z-index:9999;pointer-events:none;opacity:0;transition:opacity 0.4s;";
  document.body.appendChild(msg);
  requestAnimationFrame(() => { msg.style.opacity = "1"; });
  setTimeout(() => {
    msg.style.opacity = "0";
    setTimeout(() => msg.remove(), 500);
  }, 2000);
}

const HEX_DIRS = [
  { q: 1, r: 0 }, { q: 0, r: 1 }, { q: -1, r: 1 },
  { q: -1, r: 0 }, { q: 0, r: -1 }, { q: 1, r: -1 },
];

function posKey(q, r) { return `${q},${r}`; }

class Loom {
  constructor(tier = "small") {
    this.tier = tier;
    this.positions = LOOM_TIERS[tier].positions;
    this.grid = new Map();
    this.crossings = [];
  }

  isValid(q, r) {
    return this.positions.some((p) => p.q === q && p.r === r);
  }

  place(thread, q, r) {
    if (!this.isValid(q, r)) throw new Error(`Invalid hex position (${q}, ${r})`);
    const key = posKey(q, r);
    if (this.grid.has(key)) throw new Error(`Position (${q}, ${r}) occupied by "${this.grid.get(key).name}"`);
    this.grid.set(key, thread);
    return this;
  }

  remove(q, r) {
    const key = posKey(q, r);
    this.grid.delete(key);
    return this;
  }

  getNeighbors(q, r) {
    const neighbors = [];
    for (const d of HEX_DIRS) {
      const key = posKey(q + d.q, r + d.r);
      if (this.grid.has(key)) {
        neighbors.push({ q: q + d.q, r: r + d.r, thread: this.grid.get(key) });
      }
    }
    return neighbors;
  }

  getPositions() {
    return this.positions.map((p) => ({
      q: p.q, r: p.r,
      thread: this.grid.get(posKey(p.q, p.r)) || null,
    }));
  }

  // Upgrade to a new tier, preserving placed threads
  upgradeTier(newTier) {
    this.tier = newTier;
    this.positions = LOOM_TIERS[newTier].positions;
  }

  activate() {
    this.crossings = [];
    const resolved = new Set();
    const cascadePool = new Map();
    const pairKey = (q1, r1, q2, r2) => {
      const a = posKey(q1, r1), b = posKey(q2, r2);
      return a < b ? `${a}|${b}` : `${b}|${a}`;
    };

    const resolveCrossing = (tA, qa, ra, tB, qb, rb) => {
      const keyA = posKey(qa, ra);
      const keyB = posKey(qb, rb);
      const extraA = cascadePool.get(keyA) || {};
      const extraB = cascadePool.get(keyB) || {};

      const natureA = { ...tA.nature, ...extraA };
      const natureB = { ...tB.nature, ...extraB };

      const result = unify(natureA, natureB);
      const archetype = matchArchetype(result);

      if (archetype.match?.cascade) {
        const cascade = archetype.match.cascade;
        for (const [pq, pr] of [[qa, ra], [qb, rb]]) {
          for (const nb2 of this.getNeighbors(pq, pr)) {
            const nbKey = posKey(nb2.q, nb2.r);
            const existing = cascadePool.get(nbKey) || {};
            cascadePool.set(nbKey, { ...existing, ...cascade });
          }
        }
      }

      return {
        threadA: { ...tA, position: { q: qa, r: ra } },
        threadB: { ...tB, position: { q: qb, r: rb } },
        unification: result,
        archetype,
        cascadeApplied: [
          ...Object.keys(extraA).map(k => ({ trait: k, to: keyA })),
          ...Object.keys(extraB).map(k => ({ trait: k, to: keyB })),
        ],
      };
    };

    // Center first
    const center = this.grid.get(posKey(0, 0));
    if (center) {
      for (const nb of this.getNeighbors(0, 0)) {
        const pk = pairKey(0, 0, nb.q, nb.r);
        if (!resolved.has(pk)) {
          resolved.add(pk);
          this.crossings.push(resolveCrossing(center, 0, 0, nb.thread, nb.q, nb.r));
        }
      }
    }

    // Then remaining cells
    for (let i = 1; i < this.positions.length; i++) {
      const pos = this.positions[i];
      const thread = this.grid.get(posKey(pos.q, pos.r));
      if (!thread) continue;
      for (const nb of this.getNeighbors(pos.q, pos.r)) {
        const pk = pairKey(pos.q, pos.r, nb.q, nb.r);
        if (!resolved.has(pk)) {
          resolved.add(pk);
          this.crossings.push(resolveCrossing(thread, pos.q, pos.r, nb.thread, nb.q, nb.r));
        }
      }
    }

    return this.crossings;
  }

  static get POSITIONS() { return HEX_POSITIONS; }
  static get TIERS() { return LOOM_TIERS; }
}

// ============================================================
// AUDIO — Web Audio API sound design
// ============================================================

const GameAudio = {
  ctx: null,
  enabled: !localStorage.getItem("tink-sound-muted"),

  init() {
    if (!this.ctx) {
      try {
        this.ctx = new (window.AudioContext || window.webkitAudioContext)();
      } catch (e) {
        // AudioContext not available (headless / test environment)
        this.enabled = false;
      }
    }
  },

  playTone(freq, duration = 0.3, type = "sine", gain = 0.3) {
    if (!this.enabled || !this.ctx) return;
    try {
      const osc = this.ctx.createOscillator();
      const g = this.ctx.createGain();
      osc.type = type;
      osc.frequency.value = freq;
      g.gain.setValueAtTime(gain, this.ctx.currentTime);
      g.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + duration);
      osc.connect(g).connect(this.ctx.destination);
      osc.start();
      osc.stop(this.ctx.currentTime + duration);
    } catch (e) {
      // Gracefully ignore audio errors
    }
  },

  // Per-stability tones (pentatonic: C D E G A)
  harmony()   { this.playTone(523.25, 0.4, "sine", 0.15); },       // C5 soft
  resonance() { this.playTone(659.25, 0.5, "triangle", 0.2); },    // E5 bright
  tension()   { this.playTone(466.16, 0.3, "sawtooth", 0.12); },   // Bb4 dissonant
  paradox() {
    // Cluster chord: three dissonant tones
    this.playTone(311.13, 0.4, "sawtooth", 0.1);  // Eb4
    this.playTone(369.99, 0.4, "square", 0.08);    // F#4
    this.playTone(415.30, 0.4, "sawtooth", 0.1);  // Ab4
  },

  leverPull() {
    // Low rumble
    this.playTone(82.41, 0.6, "sawtooth", 0.1);   // E2 rumble
    setTimeout(() => this.playTone(110, 0.4, "sine", 0.08), 200);  // A2
  },

  discovery() {
    // Ascending arpeggio C-E-G-C
    this.playTone(523.25, 0.3, "sine", 0.2);       // C5
    setTimeout(() => this.playTone(659.25, 0.3, "triangle", 0.2), 150);  // E5
    setTimeout(() => this.playTone(783.99, 0.3, "sine", 0.2), 300);      // G5
    setTimeout(() => this.playTone(1046.50, 0.5, "sine", 0.25), 450);    // C6
  },

  archetypeMatch() {
    // Major chord hit
    this.playTone(523.25, 0.5, "sine", 0.2);   // C5
    this.playTone(659.25, 0.5, "sine", 0.15);  // E5
    this.playTone(783.99, 0.5, "sine", 0.15);  // G5
  },

  threadCollect() {
    // Quick ascending pip
    this.playTone(880, 0.15, "sine", 0.1);   // A5
    setTimeout(() => this.playTone(1046.50, 0.15, "sine", 0.1), 80);  // C6
  },

  shrineVisit() {
    // Ethereal pad
    this.playTone(392, 0.8, "sine", 0.1);     // G4
    this.playTone(493.88, 0.8, "sine", 0.08); // B4
    setTimeout(() => this.playTone(587.33, 0.6, "sine", 0.1), 300); // D5
  },
};

// ============================================================
// GAME STATE
// ============================================================

const canvas = document.getElementById("loomCanvas");
const ctx = canvas.getContext("2d");

const HEX_SIZE = 55;
const CENTER_X = canvas.width / 2;
const CENTER_Y = canvas.height / 2 - 10;

let loom = new Loom();
let trayThreads = [];
let selectedTrayIndex = null;
let lastCrossings = null;
let loomLocked = false;
let activationAnimRAF = null;

// Animation overlay state — drawn on top of drawLoom() each frame
const animOverlay = {
  chargeGlow: 0,        // 0..1 radial glow intensity at center
  energyPulse: null,     // { ax, ay, bx, by, progress: 0..1, color }
  hexGlows: [],          // [{ cx, cy, alpha, color }]
  stabilityLabel: null,  // { x, y, text, alpha, color }
  archetypeName: null,   // { x, y, text, alpha, tier }
  cascadeRipple: null,   // { cx, cy, radius, maxRadius, alpha, color }
  sparkles: [],          // [{ x, y, alpha, vx, vy, size, color }]
  allHexVibrate: 0,      // 0..1 vibration intensity for paradox
  nearMissLabel: null,   // { x, y, text, alpha, color }
  flavorLabel: null,     // { x, y, text, alpha, color }
  discoveryBurst: null,  // { cx, cy, radius, maxRadius, alpha, color }
};

// Stability tier visual config
const STABILITY_VFX = {
  harmony:   { color: "#5cb85c", glowColor: "rgba(92, 184, 92, 0.35)",   pulseColor: "rgba(92, 184, 92, 0.2)" },
  resonance: { color: "#5cd8d8", glowColor: "rgba(92, 216, 216, 0.45)",  pulseColor: "rgba(92, 216, 216, 0.25)" },
  tension:   { color: "#d4d84e", glowColor: "rgba(212, 216, 78, 0.4)",   pulseColor: "rgba(212, 216, 78, 0.2)" },
  paradox:   { color: "#d85c5c", glowColor: "rgba(216, 92, 92, 0.5)",    pulseColor: "rgba(216, 92, 92, 0.3)" },
};

// Pixel positions for each hex cell
function hexToPixel(q, r) {
  const x = HEX_SIZE * (3/2 * q);
  const y = HEX_SIZE * (Math.sqrt(3)/2 * q + Math.sqrt(3) * r);
  return { x: CENTER_X + x, y: CENTER_Y + y };
}

// Rarity to fill color
function rarityColor(rarity) {
  switch (rarity) {
    case "common": return "#2a2a3a";
    case "uncommon": return "#1a2e1a";
    case "rare": return "#1a2535";
    default: return "#2a2a3a";
  }
}

function rarityStroke(rarity) {
  switch (rarity) {
    case "common": return "#4a4a5a";
    case "uncommon": return "#5cb85c";
    case "rare": return "#7eb8da";
    default: return "#4a4a5a";
  }
}

// Trait colors for dots
const TRAIT_COLORS = {
  hot: "#d85c5c",
  cold: "#7eb8da",
  bright: "#d4a84e",
  volatile: "#d85c5c",
  persistent: "#6e8e6e",
  ephemeral: "#9b7ed8",
  organic: "#5cb85c",
  mechanical: "#8888aa",
  sharp: "#c8c8d8",
  liquid: "#5cd8d8",
  calm: "#5588aa",
  vast: "#7d7dba",
  emotional: "#d89b7e",
};

// ============================================================
// WANDER PHASE — node map exploration
// ============================================================

let gamePhase = "wander"; // "wander" or "weave"

// Run state: tracks progress through 5 Wander-Weave-Activate cycles
let runState = {
  cycle: 1,
  maxCycles: 5,
  loomTier: "small",
  producedArchetypes: [],   // archetypes produced this run (all cycles)
  cycleArchetypes: [],      // archetypes produced this cycle only
  newDiscoveries: 0,        // new codex discoveries this run
  active: false,
};
let wanderMap = null;      // { nodes: [], edges: [] }
let wanderPosition = null; // index into wanderMap.nodes
let wanderSatchel = [];    // collected threads
let wanderVisited = new Set(); // set of visited node indices
let wanderRejectFlash = null;  // { nodeIndex, until }
let wanderRejectRAF = null;
let wanderOfferedPool = new Set(); // thread names already shown this wander
let wanderPityCounter = 0;         // consecutive no-rare visits
let wanderDraftOpen = false;       // is the draft overlay currently open

const WANDER_SATCHEL_MAX = 6;

const WANDER_NODE_TYPES = ["thread-cluster", "clue-shrine", "hazard", "rest"];
const WANDER_NODE_COLORS = {
  "start":          "#c8c8d8", // white
  "exit":           "#d4a84e", // gold
  "thread-cluster": "#5a8acc", // blue
  "clue-shrine":    "#9b7ed8", // purple
  "hazard":         "#d85c5c", // red
  "rest":           "#5cb85c", // green
};

function generateNodeMap(columns, nodesPerCol) {
  columns = columns || 5;
  nodesPerCol = nodesPerCol || [3, 4, 3, 4, 3];

  const nodes = [];
  const edges = [];
  const colNodes = []; // colNodes[c] = array of node indices in column c

  // Column 0: single start node
  const startIdx = 0;
  nodes.push({ type: "start", col: 0, row: 0, visited: false });
  colNodes.push([startIdx]);

  // Interior columns
  for (let c = 0; c < columns; c++) {
    const count = nodesPerCol[c];
    const col = c + 1;
    const indices = [];
    for (let r = 0; r < count; r++) {
      const typeRoll = Math.random();
      let type;
      if (typeRoll < 0.50)      type = "thread-cluster";
      else if (typeRoll < 0.70) type = "clue-shrine";
      else if (typeRoll < 0.85) type = "hazard";
      else                      type = "rest";
      const idx = nodes.length;
      nodes.push({ type, col, row: r, visited: false });
      indices.push(idx);
    }
    colNodes.push(indices);
  }

  // Last column: single exit node
  const exitCol = columns + 1;
  const exitIdx = nodes.length;
  nodes.push({ type: "exit", col: exitCol, row: 0, visited: false });
  colNodes.push([exitIdx]);

  // Connect columns: each node connects to 1-2 in next column, no crossing paths
  for (let c = 0; c < colNodes.length - 1; c++) {
    const srcNodes = colNodes[c];
    const dstNodes = colNodes[c + 1];

    if (srcNodes.length === 1 && dstNodes.length >= 1) {
      // Single source connects to all destinations
      for (const dst of dstNodes) {
        edges.push({ from: srcNodes[0], to: dst });
      }
    } else if (dstNodes.length === 1) {
      // All sources connect to single destination
      for (const src of srcNodes) {
        edges.push({ from: src, to: dstNodes[0] });
      }
    } else {
      // Many-to-many: connect in row order, no crossing
      // Each source gets at least 1 connection; distribute destinations across sources
      const srcCount = srcNodes.length;
      const dstCount = dstNodes.length;

      // Assign each dst to at least one src in order
      // Strategy: map each src to a range of dsts, ensuring coverage
      for (let si = 0; si < srcCount; si++) {
        // Calculate the range of destinations this source should connect to
        const dstStart = Math.floor((si / srcCount) * dstCount);
        const dstEnd = Math.floor(((si + 1) / srcCount) * dstCount);
        // Ensure at least one connection
        const actualEnd = Math.max(dstEnd, dstStart + 1);
        for (let di = dstStart; di < actualEnd && di < dstCount; di++) {
          edges.push({ from: srcNodes[si], to: dstNodes[di] });
        }
      }

      // Ensure every destination has at least one incoming edge
      for (let di = 0; di < dstCount; di++) {
        const hasIncoming = edges.some(e => e.to === dstNodes[di]);
        if (!hasIncoming) {
          // Connect from nearest source (by row order)
          const bestSrc = Math.min(di, srcCount - 1);
          edges.push({ from: srcNodes[bestSrc], to: dstNodes[di] });
        }
      }
    }
  }

  // Deduplicate edges
  const edgeSet = new Set();
  const uniqueEdges = [];
  for (const e of edges) {
    const key = e.from + ":" + e.to;
    if (!edgeSet.has(key)) {
      edgeSet.add(key);
      uniqueEdges.push(e);
    }
  }

  return { nodes, edges: uniqueEdges, colNodes };
}

function getNodePixel(node) {
  if (!wanderMap) return { x: 0, y: 0 };
  const totalCols = wanderMap.colNodes.length;
  const marginX = 60;
  const marginY = 50;
  const usableW = canvas.width - marginX * 2;
  const usableH = canvas.height - marginY * 2;
  const colSpacing = usableW / Math.max(totalCols - 1, 1);

  const x = marginX + node.col * colSpacing;

  // Vertical centering within the column
  const nodesInCol = wanderMap.colNodes[node.col];
  const count = nodesInCol.length;
  if (count === 1) {
    return { x, y: canvas.height / 2 };
  }
  const rowSpacing = Math.min(usableH / Math.max(count - 1, 1), 80);
  const totalHeight = (count - 1) * rowSpacing;
  const startY = (canvas.height - totalHeight) / 2;
  const nodeIdx = wanderMap.nodes.indexOf(node);
  const rowInCol = nodesInCol.indexOf(nodeIdx);
  const y = startY + rowInCol * rowSpacing;

  return { x, y };
}

function getConnectedNodes(fromIndex) {
  if (!wanderMap) return [];
  const connected = [];
  for (const e of wanderMap.edges) {
    if (e.from === fromIndex) connected.push(e.to);
  }
  return connected;
}

function drawNodeMap() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);

  if (!wanderMap) return;

  // Background subtle gradient
  const bgGrad = ctx.createRadialGradient(canvas.width / 2, canvas.height / 2, 0, canvas.width / 2, canvas.height / 2, canvas.width * 0.6);
  bgGrad.addColorStop(0, "rgba(126, 184, 218, 0.03)");
  bgGrad.addColorStop(1, "rgba(0, 0, 0, 0)");
  ctx.fillStyle = bgGrad;
  ctx.fillRect(0, 0, canvas.width, canvas.height);

  const connectedToPlayer = wanderPosition !== null ? getConnectedNodes(wanderPosition) : [];

  // Draw edges
  for (const edge of wanderMap.edges) {
    const fromNode = wanderMap.nodes[edge.from];
    const toNode = wanderMap.nodes[edge.to];
    const fromPx = getNodePixel(fromNode);
    const toPx = getNodePixel(toNode);

    const isAvailable = edge.from === wanderPosition && connectedToPlayer.includes(edge.to);
    const isTraversed = wanderVisited.has(edge.from) && wanderVisited.has(edge.to);

    ctx.beginPath();
    ctx.moveTo(fromPx.x, fromPx.y);
    ctx.lineTo(toPx.x, toPx.y);

    if (isAvailable) {
      ctx.strokeStyle = "rgba(212, 168, 78, 0.6)";
      ctx.lineWidth = 2;
      // Dashed line for available paths
      ctx.setLineDash([6, 4]);
    } else if (isTraversed) {
      ctx.strokeStyle = "rgba(126, 184, 218, 0.3)";
      ctx.lineWidth = 1.5;
      ctx.setLineDash([]);
    } else {
      ctx.strokeStyle = "rgba(30, 30, 46, 0.8)";
      ctx.lineWidth = 1;
      ctx.setLineDash([]);
    }

    ctx.stroke();
    ctx.setLineDash([]);
  }

  // Draw nodes
  const NODE_RADIUS = 16;
  for (let i = 0; i < wanderMap.nodes.length; i++) {
    const node = wanderMap.nodes[i];
    const px = getNodePixel(node);
    const isCurrentPos = i === wanderPosition;
    const isVisited = wanderVisited.has(i);
    const isReachable = connectedToPlayer.includes(i);
    const baseColor = WANDER_NODE_COLORS[node.type] || "#6e6e8e";

    // Reject flash
    if (wanderRejectFlash && wanderRejectFlash.nodeIndex === i) {
      const elapsed = performance.now() - (wanderRejectFlash.until - 400);
      const pulse = Math.sin(elapsed * 0.025) * 0.5 + 0.5;
      ctx.save();
      ctx.beginPath();
      ctx.arc(px.x, px.y, NODE_RADIUS + 4, 0, Math.PI * 2);
      ctx.fillStyle = "rgba(216, 92, 92, " + (0.15 + pulse * 0.2) + ")";
      ctx.fill();
      ctx.restore();
    }

    // Player glow
    if (isCurrentPos) {
      ctx.save();
      const glowGrad = ctx.createRadialGradient(px.x, px.y, NODE_RADIUS * 0.5, px.x, px.y, NODE_RADIUS * 2.5);
      glowGrad.addColorStop(0, "rgba(212, 168, 78, 0.35)");
      glowGrad.addColorStop(1, "rgba(212, 168, 78, 0)");
      ctx.fillStyle = glowGrad;
      ctx.beginPath();
      ctx.arc(px.x, px.y, NODE_RADIUS * 2.5, 0, Math.PI * 2);
      ctx.fill();
      ctx.restore();
    }

    // Reachable node subtle glow
    if (isReachable && !isCurrentPos) {
      ctx.save();
      ctx.shadowColor = baseColor;
      ctx.shadowBlur = 10;
      ctx.beginPath();
      ctx.arc(px.x, px.y, NODE_RADIUS + 3, 0, Math.PI * 2);
      ctx.strokeStyle = "rgba(212, 168, 78, 0.3)";
      ctx.lineWidth = 1;
      ctx.stroke();
      ctx.restore();
    }

    // Node circle
    ctx.beginPath();
    ctx.arc(px.x, px.y, NODE_RADIUS, 0, Math.PI * 2);

    if (isVisited && !isCurrentPos) {
      // Dimmed visited node
      ctx.fillStyle = "rgba(18, 18, 26, 0.7)";
      ctx.fill();
      ctx.strokeStyle = baseColor;
      ctx.globalAlpha = 0.4;
      ctx.lineWidth = 1.5;
      ctx.stroke();
      ctx.globalAlpha = 1;
    } else {
      // Unvisited or current node
      ctx.fillStyle = isCurrentPos ? baseColor : "rgba(18, 18, 26, 0.8)";
      ctx.fill();
      ctx.strokeStyle = baseColor;
      ctx.lineWidth = isCurrentPos ? 2.5 : 1.5;
      ctx.stroke();
    }

    // Node type icon/label
    ctx.save();
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    ctx.font = "bold 10px 'Segoe UI', system-ui, sans-serif";

    if (isVisited && !isCurrentPos) {
      ctx.globalAlpha = 0.4;
    }

    const labelColor = isCurrentPos ? "#0a0a0f" : baseColor;
    ctx.fillStyle = labelColor;

    // Short icon labels
    const iconMap = {
      "start": "\u25C9",      // circle with dot
      "exit": "\u2302",       // house/exit
      "thread-cluster": "\u2261",  // triple bar (threads)
      "clue-shrine": "\u2735",    // asterisk (shrine)
      "hazard": "\u26A0",         // warning
      "rest": "\u2618",           // shamrock (rest)
    };
    ctx.font = isCurrentPos ? "bold 14px serif" : "13px serif";
    ctx.fillText(iconMap[node.type] || "?", px.x, px.y);
    ctx.restore();

    // Type label below node
    if (!isVisited || isCurrentPos) {
      ctx.save();
      ctx.textAlign = "center";
      ctx.textBaseline = "top";
      ctx.font = "9px monospace";
      ctx.fillStyle = isCurrentPos ? baseColor : "rgba(200, 200, 216, 0.5)";
      const typeLabels = {
        "start": "start",
        "exit": "exit",
        "thread-cluster": "threads",
        "clue-shrine": "shrine",
        "hazard": "hazard",
        "rest": "rest",
      };
      ctx.fillText(typeLabels[node.type] || node.type, px.x, px.y + NODE_RADIUS + 4);
      ctx.restore();
    }
  }

  // Title at bottom
  ctx.fillStyle = "#3a3a4a";
  ctx.font = "italic 11px Georgia, serif";
  ctx.textAlign = "center";
  ctx.fillText("the winding path", canvas.width / 2, canvas.height - 12);
}

function hitTestMapNode(clientX, clientY) {
  if (!wanderMap) return -1;
  const rect = canvas.getBoundingClientRect();
  const scaleX = canvas.width / rect.width;
  const scaleY = canvas.height / rect.height;
  const mx = (clientX - rect.left) * scaleX;
  const my = (clientY - rect.top) * scaleY;
  const NODE_RADIUS = 16;
  const CLICK_RADIUS = NODE_RADIUS + 8; // generous click target

  for (let i = 0; i < wanderMap.nodes.length; i++) {
    const px = getNodePixel(wanderMap.nodes[i]);
    const dist = Math.sqrt((mx - px.x) ** 2 + (my - px.y) ** 2);
    if (dist < CLICK_RADIUS) return i;
  }
  return -1;
}

function triggerWanderRejectFlash(nodeIndex) {
  wanderRejectFlash = { nodeIndex, until: performance.now() + 400 };
  if (!wanderRejectRAF) animateWanderRejectFlash();
}

function animateWanderRejectFlash() {
  if (!wanderRejectFlash || performance.now() > wanderRejectFlash.until) {
    wanderRejectFlash = null;
    wanderRejectRAF = null;
    drawNodeMap();
    return;
  }
  drawNodeMap();
  wanderRejectRAF = requestAnimationFrame(animateWanderRejectFlash);
}

function handleMapClick(clientX, clientY) {
  if (!wanderMap || wanderPosition === null) return;
  if (wanderDraftOpen || wanderShrineOpen) return; // don't allow movement while overlay is open

  const clickedIndex = hitTestMapNode(clientX, clientY);
  if (clickedIndex < 0) return; // clicked empty space

  // Check if the clicked node is reachable from current position
  const connected = getConnectedNodes(wanderPosition);
  if (!connected.includes(clickedIndex)) {
    // Invalid move — flash red
    triggerWanderRejectFlash(clickedIndex);
    return;
  }

  // Move player
  wanderPosition = clickedIndex;
  wanderVisited.add(clickedIndex);
  wanderMap.nodes[clickedIndex].visited = true;

  // Check if reached exit
  if (wanderMap.nodes[clickedIndex].type === "exit") {
    // Transition to Weave phase
    drawNodeMap();
    setTimeout(() => startWeave(wanderSatchel), 300);
    return;
  }

  // Thread-cluster node: show draft interface
  if (wanderMap.nodes[clickedIndex].type === "thread-cluster") {
    drawNodeMap();
    showThreadDraft(wanderMap.nodes[clickedIndex]);
    return;
  }

  // Clue-shrine node: show shrine clue
  if (wanderMap.nodes[clickedIndex].type === "clue-shrine") {
    drawNodeMap();
    showShrineClue(wanderMap.nodes[clickedIndex]);
    return;
  }

  updateSatchelDisplay();
  drawNodeMap();
}

function updateSatchelDisplay() {
  const countEl = document.getElementById("satchelCount");
  if (countEl) {
    countEl.textContent = wanderSatchel.length + " / " + WANDER_SATCHEL_MAX;
  }
  // Update satchel contents list
  const contentsEl = document.getElementById("satchelContents");
  if (contentsEl) {
    contentsEl.innerHTML = "";
    for (const thread of wanderSatchel) {
      const tag = document.createElement("span");
      tag.className = "satchel-thread rarity-" + thread.rarity;
      tag.textContent = thread.name;
      contentsEl.appendChild(tag);
    }
  }
}

function generateThreadOptions(count) {
  // Filter out already-offered threads
  let available = THREADS.filter(t => !wanderOfferedPool.has(t.name));

  // Graceful degradation: if pool is depleted, allow repeats
  if (available.length < count) {
    available = [...THREADS];
  }

  // Pity mechanic: after 3 consecutive no-rare visits, guarantee a rare
  const needsPity = wanderPityCounter >= 3;

  let options;
  if (needsPity) {
    // Guarantee at least one rare thread
    const rares = available.filter(t => t.rarity === "rare");
    const nonRares = available.filter(t => t.rarity !== "rare");

    if (rares.length > 0) {
      // Pick 1 rare, fill rest from non-rares
      const shuffledRares = [...rares].sort(() => Math.random() - 0.5);
      const shuffledNonRares = [...nonRares].sort(() => Math.random() - 0.5);
      options = [shuffledRares[0]];
      for (let i = 0; i < shuffledNonRares.length && options.length < count; i++) {
        options.push(shuffledNonRares[i]);
      }
      // If still not enough, fill from rares
      for (let i = 1; i < shuffledRares.length && options.length < count; i++) {
        options.push(shuffledRares[i]);
      }
    } else {
      // No rares available at all (shouldn't happen, but graceful)
      const shuffled = [...available].sort(() => Math.random() - 0.5);
      options = shuffled.slice(0, count);
    }
  } else {
    const shuffled = [...available].sort(() => Math.random() - 0.5);
    options = shuffled.slice(0, count);
  }

  // Track offered threads
  for (const t of options) {
    wanderOfferedPool.add(t.name);
  }

  // Update pity counter
  const hasRare = options.some(t => t.rarity === "rare");
  if (hasRare) {
    wanderPityCounter = 0;
  } else {
    wanderPityCounter++;
  }

  return options;
}

function showThreadDraft(node) {
  wanderDraftOpen = true;
  const overlay = document.getElementById("threadDraftOverlay");
  const panel = document.getElementById("threadDraftPanel");
  panel.innerHTML = "";

  // Title
  const title = document.createElement("div");
  title.className = "thread-draft-title";
  title.textContent = "Thread Cluster";
  panel.appendChild(title);

  // Satchel full check
  if (wanderSatchel.length >= WANDER_SATCHEL_MAX) {
    const notice = document.createElement("div");
    notice.className = "satchel-full-notice";
    notice.textContent = "Your satchel is full.";
    panel.appendChild(notice);

    const closeBtn = document.createElement("button");
    closeBtn.className = "thread-draft-skip";
    closeBtn.textContent = "Continue";
    closeBtn.addEventListener("click", closeDraft);
    panel.appendChild(closeBtn);

    overlay.classList.add("open");
    return;
  }

  // Subtitle with remaining capacity
  const remaining = WANDER_SATCHEL_MAX - wanderSatchel.length;
  const subtitle = document.createElement("div");
  subtitle.className = "thread-draft-subtitle";
  subtitle.textContent = "Choose a thread to add to your satchel (" + remaining + " slot" + (remaining !== 1 ? "s" : "") + " remaining)";
  panel.appendChild(subtitle);

  // Generate 2-3 thread options
  const optionCount = 2 + Math.floor(Math.random() * 2); // 2 or 3
  const options = generateThreadOptions(optionCount);

  const cardsContainer = document.createElement("div");
  cardsContainer.className = "thread-draft-cards";

  for (const thread of options) {
    const card = document.createElement("div");
    card.className = "thread-draft-card";

    // Header: name + rarity
    const header = document.createElement("div");
    const nameSpan = document.createElement("span");
    nameSpan.className = "draft-card-name";
    nameSpan.textContent = thread.name;
    header.appendChild(nameSpan);

    const raritySpan = document.createElement("span");
    raritySpan.className = "rarity-badge rarity-" + thread.rarity;
    raritySpan.textContent = thread.rarity;
    header.appendChild(raritySpan);
    card.appendChild(header);

    // Nature traits as badges
    const traitsDiv = document.createElement("div");
    traitsDiv.className = "nature-traits";
    for (const trait of Object.keys(thread.nature)) {
      if (thread.nature[trait]) {
        const tag = document.createElement("span");
        tag.className = "trait-tag";
        tag.textContent = trait;
        traitsDiv.appendChild(tag);
      }
    }
    card.appendChild(traitsDiv);

    // Click to collect
    card.addEventListener("click", () => {
      collectThread(thread);
    });

    cardsContainer.appendChild(card);
  }

  panel.appendChild(cardsContainer);

  // Skip button
  const skipBtn = document.createElement("button");
  skipBtn.className = "thread-draft-skip";
  skipBtn.textContent = "Skip";
  skipBtn.addEventListener("click", closeDraft);
  panel.appendChild(skipBtn);

  overlay.classList.add("open");
}

function collectThread(thread) {
  if (wanderSatchel.length >= WANDER_SATCHEL_MAX) return;
  wanderSatchel.push(thread);
  GameAudio.init();
  GameAudio.threadCollect();
  updateSatchelDisplay();
  closeDraft();
}

function closeDraft() {
  wanderDraftOpen = false;
  const overlay = document.getElementById("threadDraftOverlay");
  overlay.classList.remove("open");
}

// ============================================================
// CLUE SHRINE — thematic hints for undiscovered archetypes
// ============================================================

const CLUES = {
  // Natural phenomena
  "Aurora":             "Where brilliance meets the breath of winter, colors dance that no painter could name.",
  "Stormglass":         "Restless light trapped in flowing glass — it shifts, it sparks, it never settles.",
  "Permafrost":         "What endures beneath the cold outlasts the mountains themselves, vast and unyielding.",
  "Wildfire":           "Heat born of living things devours and transforms — never tame, never still.",

  // Emotional constructs
  "Vendetta Engine":    "A feeling given gears and purpose, turning endlessly on the axis of its own conviction.",
  "Euphoria Cascade":   "Radiance born from the heart, burning so bright it cannot hold its own shape.",
  "Quiet Resolve":      "A still feeling that refuses to break — patient as stone, steady as breath.",
  "Heartstring":        "Something alive and tender hums between two points, warm to the touch.",

  // Mythological archetypes
  "Web of Wyrd":        "Vast threads pulled taut, each knot precise as a blade — what endures remembers everything.",
  "Anansi's Thread":    "A keen and living line, here and gone, catching meaning before it can escape.",
  "Bifrost Shard":      "A brilliant fragment spanning impossible distance, cold as starlight, wide as sky.",

  // Inventions
  "Perpetual Motion":   "Gears that turn without ceasing, faithful to their own rhythm beyond all reason.",
  "Resonance Crystal":  "Precision meets radiance — cut to sing, shaped to amplify what others whisper.",
  "Living Clockwork":   "Mechanisms that breathe, springs that grow — where the built and the born are one.",

  // Paradox archetypes
  "Paradox Bloom":      "In the garden of contradictions, something impossible flowers — fed by what should destroy it.",
  "Schrodinger's Thread": "A mechanism that exists in two states until examined — wound and unwound at once.",
  "Oxymoron Engine":    "It endures by embracing its own contradictions, each impossibility another revolution.",

  // Abstract
  "Echo Chamber":       "Vast and fleeting — whispers stretch across emptiness, louder each time they return.",
  "Void Lens":          "Emptiness given edge and reach, cold focus carving meaning from the absence.",

  // Legendary
  "Tapestry of Ages":   "All that endures, all that lives, all that shines, all that spans — woven into one remembering.",
  "Paradox Engine":     "Contradiction made permanent, volatile purpose in mechanical form — every impossibility fuels the next.",
  "The Unraveling":     "Swift, sharp, vast, and restless — feeling turned to transformation so fast it looks like ending.",
};

let wanderShrineOpen = false;

function pickShrineClue() {
  const discovered = codexData.discovered;
  const hints = codexData.hints;

  // Find archetypes not yet discovered
  const undiscovered = CATALOG.filter(a => !(a.name in discovered));

  if (undiscovered.length === 0) {
    return null; // all discovered
  }

  // Prefer archetypes that don't have hints yet
  const noHint = undiscovered.filter(a => !(a.name in hints));

  if (noHint.length > 0) {
    // Pick a random undiscovered archetype without a hint
    const pick = noHint[Math.floor(Math.random() * noHint.length)];
    return { name: pick.name, clue: CLUES[pick.name] };
  }

  // All undiscovered archetypes already have hints — pick a random one
  const pick = undiscovered[Math.floor(Math.random() * undiscovered.length)];
  return { name: pick.name, clue: CLUES[pick.name] };
}

function showShrineClue(node) {
  wanderShrineOpen = true;
  GameAudio.init();
  GameAudio.shrineVisit();
  const overlay = document.getElementById("shrineOverlay");
  const panel = document.getElementById("shrinePanel");
  panel.innerHTML = "";

  // Title
  const title = document.createElement("div");
  title.className = "shrine-title";
  title.textContent = "The Shrine Speaks\u2026";
  panel.appendChild(title);

  const chosen = pickShrineClue();

  if (chosen === null) {
    // All archetypes discovered
    const silent = document.createElement("div");
    silent.className = "shrine-silent";
    silent.textContent = "The shrine is silent \u2014 you have found all there is to find.";
    panel.appendChild(silent);
  } else {
    // Display clue text
    const clueText = document.createElement("div");
    clueText.className = "shrine-clue-text";
    clueText.textContent = "\u201C" + chosen.clue + "\u201D";
    panel.appendChild(clueText);

    // Show archetype name (but not recipe)
    const archName = document.createElement("div");
    archName.className = "shrine-archetype-name";
    archName.innerHTML = "A whisper about <em>" + chosen.name + "</em>";
    panel.appendChild(archName);

    // Save to codex
    Codex.addHint(codexData, chosen.clue, chosen.name);
    updateCodexBtnCount();
  }

  // Dismiss button
  const dismissBtn = document.createElement("button");
  dismissBtn.className = "shrine-dismiss";
  dismissBtn.textContent = "Noted";
  dismissBtn.addEventListener("click", closeShrineOverlay);
  panel.appendChild(dismissBtn);

  // Brief purple glow flourish
  panel.style.boxShadow = "0 0 50px rgba(155, 126, 216, 0.35)";
  setTimeout(() => {
    panel.style.boxShadow = "0 0 30px rgba(155, 126, 216, 0.15)";
  }, 600);

  overlay.classList.add("open");
}

function closeShrineOverlay() {
  wanderShrineOpen = false;
  const overlay = document.getElementById("shrineOverlay");
  overlay.classList.remove("open");
}

// ============================================================
// RUN MANAGEMENT — 5-cycle Wander→Weave→Activate loop
// ============================================================

function startRun() {
  runState.cycle = 1;
  runState.maxCycles = 5;
  runState.loomTier = computeLoomTier();
  runState.producedArchetypes = [];
  runState.cycleArchetypes = [];
  runState.newDiscoveries = 0;
  runState.active = true;

  codexData.stats.runs++;
  Codex.save(codexData);

  updateCycleIndicator();
  startWander();
}

function nextCycle() {
  runState.cycle++;
  runState.cycleArchetypes = [];

  // Check for loom tier upgrade between cycles
  runState.loomTier = computeLoomTier();

  updateCycleIndicator();
  startWander();
}

function endRun() {
  runState.active = false;
  showRunSummary();
}

function updateCycleIndicator() {
  const el = document.getElementById("cycleIndicator");
  if (!runState.active) {
    el.style.display = "none";
    return;
  }
  el.style.display = "";
  el.innerHTML = 'Cycle <span class="cycle-current">' + runState.cycle + '</span> / ' + runState.maxCycles;
}

function showRunSummary() {
  const overlay = document.getElementById("runSummaryOverlay");
  const panel = document.getElementById("runSummaryPanel");

  const uniqueArchetypes = [...new Set(runState.producedArchetypes.map(a => a.name))];
  const discovered = Object.keys(codexData.discovered).length;
  const completionPct = Math.round((discovered / CATALOG.length) * 100);

  panel.innerHTML = "";

  const heading = document.createElement("h2");
  heading.textContent = "Run Complete";
  panel.appendChild(heading);

  const stats = [
    { label: "Cycles completed", value: runState.cycle },
    { label: "Archetypes produced", value: runState.producedArchetypes.length },
    { label: "Unique archetypes", value: uniqueArchetypes.length },
    { label: "New discoveries", value: runState.newDiscoveries },
    { label: "Codex completion", value: completionPct + "%" },
  ];

  for (const s of stats) {
    const div = document.createElement("div");
    div.className = "run-summary-stat";
    div.innerHTML = s.label + ': <span class="stat-value">' + s.value + '</span>';
    panel.appendChild(div);
  }

  // List unique archetypes produced
  if (uniqueArchetypes.length > 0) {
    const listDiv = document.createElement("div");
    listDiv.style.cssText = "margin-top: 0.8rem; font-size: 0.8rem; color: #6e6e8e; font-style: italic;";
    listDiv.textContent = uniqueArchetypes.join(", ");
    panel.appendChild(listDiv);
  }

  const actions = document.createElement("div");
  actions.className = "run-summary-actions";

  const newRunBtn = document.createElement("button");
  newRunBtn.className = "btn btn-primary";
  newRunBtn.textContent = "New Run";
  newRunBtn.addEventListener("click", () => {
    overlay.classList.remove("open");
    startRun();
  });
  actions.appendChild(newRunBtn);

  panel.appendChild(actions);

  overlay.classList.add("open");
}

function startWander() {
  gamePhase = "wander";

  // Generate a new map
  wanderMap = generateNodeMap();
  wanderPosition = 0; // start node
  wanderSatchel = [];
  wanderVisited = new Set([0]);
  wanderOfferedPool = new Set();
  wanderPityCounter = 0;
  wanderDraftOpen = false;
  wanderMap.nodes[0].visited = true;

  // Hide Weave UI
  const subtitle = document.querySelector(".header .subtitle");
  if (subtitle) subtitle.textContent = "The Winding Path";

  document.querySelector(".tray-label").style.display = "none";
  document.getElementById("threadTray").style.display = "none";
  document.getElementById("weaveControls").style.display = "none";
  document.getElementById("resultsPanel").style.display = "none";
  document.getElementById("runSummaryOverlay").classList.remove("open");

  // Show Wander UI
  document.getElementById("wanderHud").classList.add("active");
  updateSatchelDisplay();
  updateCycleIndicator();

  drawNodeMap();
}

function startWeave(collectedThreads) {
  gamePhase = "weave";

  // Show Weave UI
  const subtitle = document.querySelector(".header .subtitle");
  if (subtitle) subtitle.textContent = "The Loom";

  document.querySelector(".tray-label").style.display = "";
  document.getElementById("threadTray").style.display = "";
  document.getElementById("weaveControls").style.display = "";

  // Hide Wander UI
  document.getElementById("wanderHud").classList.remove("active");
  closeDraft(); // ensure draft overlay is closed
  updateCycleIndicator();

  // Clear wander state
  wanderMap = null;
  wanderPosition = null;

  // Initialize the loom — reset animation state
  runState.cycleArchetypes = [];

  loomLocked = false;
  if (activationAnimRAF) {
    cancelAnimationFrame(activationAnimRAF);
    activationAnimRAF = null;
  }
  animOverlay.chargeGlow = 0;
  animOverlay.energyPulse = null;
  animOverlay.hexGlows = [];
  animOverlay.stabilityLabel = null;
  animOverlay.archetypeName = null;
  animOverlay.cascadeRipple = null;
  animOverlay.sparkles = [];
  animOverlay.allHexVibrate = 0;
  animOverlay.nearMissLabel = null;
  animOverlay.flavorLabel = null;
  animOverlay.discoveryBurst = null;

  const activateBtn = document.getElementById("activateBtn");
  const resetBtn = document.getElementById("resetBtn");
  const trayEl = document.getElementById("threadTray");
  const trayLabel = document.querySelector(".tray-label");
  const resultsPanel = document.getElementById("resultsPanel");
  activateBtn.classList.remove("btn-locked");
  resetBtn.classList.remove("btn-locked");
  resetBtn.style.display = "";
  trayEl.classList.remove("tray-dimmed");
  if (trayLabel) trayLabel.style.opacity = "";
  canvas.classList.remove("shake");
  canvas.style.filter = "";
  canvas.style.transform = "";
  document.getElementById("paradoxVignette").classList.remove("active");
  document.getElementById("codexBtn").classList.remove("discovery-pulse");
  resultsPanel.classList.remove("fade-in");

  // Determine loom tier from codex discoveries
  currentLoomTier = computeLoomTier();
  loom = new Loom(currentLoomTier);
  selectedTrayIndex = null;
  lastCrossings = null;
  resultsPanel.style.display = "none";

  // If threads were collected during wander, use them; otherwise random
  if (collectedThreads && collectedThreads.length > 0) {
    const threads = collectedThreads.slice();
    // Place up to 3 on loom, rest in tray
    const toPlace = Math.min(3, threads.length);
    const ringPositions = getHexPositions().slice(1);
    const shuffledRing = [...ringPositions].sort(() => Math.random() - 0.5);

    if (toPlace >= 1) loom.place(threads[0], 0, 0);
    if (toPlace >= 2) loom.place(threads[1], shuffledRing[0].q, shuffledRing[0].r);
    if (toPlace >= 3) loom.place(threads[2], shuffledRing[1].q, shuffledRing[1].r);

    trayThreads = threads.slice(toPlace);
  } else {
    // Fallback: random threads (same as original initGame)
    const selected = randomThreads(5);
    const ringPositions = getHexPositions().slice(1);
    const shuffledRing = [...ringPositions].sort(() => Math.random() - 0.5);

    loom.place(selected[0], 0, 0);
    loom.place(selected[1], shuffledRing[0].q, shuffledRing[0].r);
    loom.place(selected[2], shuffledRing[1].q, shuffledRing[1].r);

    trayThreads = [selected[3], selected[4]];
  }

  drawLoom();
  renderTray();
  updateHint();
}

// ============================================================
// DRAG-AND-DROP STATE
// ============================================================

let dragState = null;     // { threadIndex, ghost, hoverHex: {q,r}|null, occupied: bool }
let rejectFlashHex = null; // {q, r, until: timestamp} — for red flash
let rejectFlashRAF = null;

function hitTestHex(clientX, clientY) {
  const rect = canvas.getBoundingClientRect();
  const scaleX = canvas.width / rect.width;
  const scaleY = canvas.height / rect.height;
  const mx = (clientX - rect.left) * scaleX;
  const my = (clientY - rect.top) * scaleY;
  for (const pos of getHexPositions()) {
    const px = hexToPixel(pos.q, pos.r);
    const dist = Math.sqrt((mx - px.x) ** 2 + (my - px.y) ** 2);
    if (dist < HEX_SIZE - 5) {
      return { q: pos.q, r: pos.r, occupied: loom.grid.has(posKey(pos.q, pos.r)) };
    }
  }
  return null;
}

function createGhostEl(thread) {
  const ghost = document.createElement("div");
  ghost.className = "drag-ghost";

  const header = document.createElement("div");
  const nameSpan = document.createElement("span");
  nameSpan.className = "card-name";
  nameSpan.textContent = thread.name;
  header.appendChild(nameSpan);
  const raritySpan = document.createElement("span");
  raritySpan.className = "card-rarity rarity-" + thread.rarity;
  raritySpan.textContent = thread.rarity;
  header.appendChild(raritySpan);
  ghost.appendChild(header);

  const traitsDiv = document.createElement("div");
  traitsDiv.className = "card-traits";
  for (const trait of Object.keys(thread.nature)) {
    const tag = document.createElement("span");
    tag.className = "trait-tag";
    tag.textContent = trait;
    tag.style.borderColor = TRAIT_COLORS[trait] || "rgba(126, 184, 218, 0.15)";
    tag.style.color = TRAIT_COLORS[trait] || "#5cd8d8";
    traitsDiv.appendChild(tag);
  }
  ghost.appendChild(traitsDiv);

  document.body.appendChild(ghost);
  return ghost;
}

function startDrag(threadIndex, clientX, clientY) {
  if (loomLocked) return;
  const thread = trayThreads[threadIndex];
  if (!thread) return;

  const ghost = createGhostEl(thread);
  ghost.style.left = clientX + "px";
  ghost.style.top = clientY + "px";

  dragState = { threadIndex, ghost, hoverHex: null, occupied: false };

  // Dim the source card
  const cards = document.querySelectorAll(".thread-card");
  if (cards[threadIndex]) cards[threadIndex].classList.add("dragging");

  updateHint();
}

function moveDrag(clientX, clientY) {
  if (!dragState) return;
  dragState.ghost.style.left = clientX + "px";
  dragState.ghost.style.top = clientY + "px";

  const hit = hitTestHex(clientX, clientY);
  const prevKey = dragState.hoverHex ? posKey(dragState.hoverHex.q, dragState.hoverHex.r) : null;
  const newKey = hit ? posKey(hit.q, hit.r) : null;

  if (prevKey !== newKey || (hit && dragState.occupied !== hit.occupied)) {
    dragState.hoverHex = hit ? { q: hit.q, r: hit.r } : null;
    dragState.occupied = hit ? hit.occupied : false;
    drawLoom();
  }
}

function endDrag(clientX, clientY) {
  if (!dragState) return;

  const hit = hitTestHex(clientX, clientY);
  const { threadIndex, ghost } = dragState;
  const thread = trayThreads[threadIndex];

  // Clean up ghost
  ghost.remove();

  // Un-dim card
  const cards = document.querySelectorAll(".thread-card");
  if (cards[threadIndex]) cards[threadIndex].classList.remove("dragging");

  if (hit && !hit.occupied && thread) {
    // Valid drop: place the thread
    loom.place(thread, hit.q, hit.r);
    trayThreads.splice(threadIndex, 1);
    selectedTrayIndex = null;
    lastCrossings = null;
    document.getElementById("resultsPanel").style.display = "none";
  } else if (hit && hit.occupied) {
    // Rejected: red flash on the occupied cell
    triggerRejectFlash(hit.q, hit.r);
  }
  // else: dropped elsewhere — cancel, thread stays in tray

  dragState = null;
  drawLoom();
  renderTray();
  updateHint();
}

function cancelDrag() {
  if (!dragState) return;
  dragState.ghost.remove();
  const cards = document.querySelectorAll(".thread-card");
  if (cards[dragState.threadIndex]) cards[dragState.threadIndex].classList.remove("dragging");
  dragState = null;
  drawLoom();
  updateHint();
}

function triggerRejectFlash(q, r) {
  rejectFlashHex = { q, r, until: performance.now() + 400 };
  if (!rejectFlashRAF) animateRejectFlash();
}

function animateRejectFlash() {
  if (!rejectFlashHex || performance.now() > rejectFlashHex.until) {
    rejectFlashHex = null;
    rejectFlashRAF = null;
    drawLoom();
    return;
  }
  drawLoom();
  rejectFlashRAF = requestAnimationFrame(animateRejectFlash);
}

// ============================================================
// CANVAS RENDERER
// ============================================================

function drawHexagon(cx, cy, size, fill, stroke, lineWidth) {
  ctx.beginPath();
  for (let i = 0; i < 6; i++) {
    const angle = (Math.PI / 3) * i - Math.PI / 6;
    const hx = cx + size * Math.cos(angle);
    const hy = cy + size * Math.sin(angle);
    if (i === 0) ctx.moveTo(hx, hy);
    else ctx.lineTo(hx, hy);
  }
  ctx.closePath();
  if (fill) {
    ctx.fillStyle = fill;
    ctx.fill();
  }
  if (stroke) {
    ctx.strokeStyle = stroke;
    ctx.lineWidth = lineWidth || 1.5;
    ctx.stroke();
  }
}

function drawLoom() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);

  // Draw subtle glow at center
  const grad = ctx.createRadialGradient(CENTER_X, CENTER_Y, 0, CENTER_X, CENTER_Y, HEX_SIZE * 3.5);
  grad.addColorStop(0, "rgba(126, 184, 218, 0.06)");
  grad.addColorStop(1, "rgba(126, 184, 218, 0)");
  ctx.fillStyle = grad;
  ctx.fillRect(0, 0, canvas.width, canvas.height);

  // Draw edge connections between adjacent occupied cells
  const positions = loom.getPositions();
  ctx.strokeStyle = "#1e1e2e";
  ctx.lineWidth = 1;
  for (let i = 0; i < positions.length; i++) {
    const posA = positions[i];
    const pxA = hexToPixel(posA.q, posA.r);
    for (let j = i + 1; j < positions.length; j++) {
      const posB = positions[j];
      // Check adjacency
      const dq = posB.q - posA.q;
      const dr = posB.r - posA.r;
      const isAdj = HEX_DIRS.some(d => d.q === dq && d.r === dr);
      if (isAdj) {
        const pxB = hexToPixel(posB.q, posB.r);
        // Brighter line if both occupied
        if (posA.thread && posB.thread) {
          ctx.strokeStyle = "rgba(126, 184, 218, 0.25)";
          ctx.lineWidth = 1.5;
        } else {
          ctx.strokeStyle = "#1e1e2e";
          ctx.lineWidth = 1;
        }
        ctx.beginPath();
        ctx.moveTo(pxA.x, pxA.y);
        ctx.lineTo(pxB.x, pxB.y);
        ctx.stroke();
      }
    }
  }

  // Draw hex cells
  for (const pos of positions) {
    const px = hexToPixel(pos.q, pos.r);
    const isCenter = pos.q === 0 && pos.r === 0;

    if (pos.thread) {
      // Occupied cell
      const fill = rarityColor(pos.thread.rarity);
      const stroke = rarityStroke(pos.thread.rarity);
      drawHexagon(px.x, px.y, HEX_SIZE - 2, fill, stroke, isCenter ? 2.5 : 2);

      // Thread name
      ctx.fillStyle = "#c8c8d8";
      ctx.font = "bold 12px 'Segoe UI', system-ui, sans-serif";
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";
      ctx.fillText(pos.thread.name, px.x, px.y - 6);

      // Rarity label
      ctx.fillStyle = rarityStroke(pos.thread.rarity);
      ctx.font = "9px monospace";
      ctx.fillText(pos.thread.rarity, px.x, px.y + 8);

      // Trait dots
      const traits = Object.keys(pos.thread.nature);
      const dotSpacing = 8;
      const totalWidth = (traits.length - 1) * dotSpacing;
      const startX = px.x - totalWidth / 2;
      const dotY = px.y + 22;

      for (let i = 0; i < traits.length; i++) {
        const color = TRAIT_COLORS[traits[i]] || "#6e6e8e";
        ctx.beginPath();
        ctx.arc(startX + i * dotSpacing, dotY, 3, 0, Math.PI * 2);
        ctx.fillStyle = color;
        ctx.fill();
      }
    } else {
      // Empty cell
      drawHexagon(px.x, px.y, HEX_SIZE - 2, "rgba(18, 18, 26, 0.5)", "#2a2a3a", 1);

      // Position label
      const labels = {
        "0,0": "center",
        "1,0": "E", "0,1": "SE", "-1,1": "SW", "-1,0": "W", "0,-1": "NW", "1,-1": "NE",
        "2,0": "2E", "2,-1": "2ENE", "2,-2": "2NE", "1,-2": "2NNE", "0,-2": "2N", "-1,-1": "2NNW",
        "-2,0": "2W", "-2,1": "2WSW", "-2,2": "2SW", "-1,2": "2SSW", "0,2": "2S", "1,1": "2SSE",
      };
      ctx.fillStyle = "#333";
      ctx.font = "10px monospace";
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";
      ctx.fillText(labels[posKey(pos.q, pos.r)] || "", px.x, px.y);
    }
  }

  // Drag hover highlight
  if (dragState && dragState.hoverHex) {
    const hPx = hexToPixel(dragState.hoverHex.q, dragState.hoverHex.r);
    if (dragState.occupied) {
      // Red highlight for occupied cell
      drawHexagon(hPx.x, hPx.y, HEX_SIZE - 2, "rgba(216, 92, 92, 0.15)", "#d85c5c", 2.5);
    } else {
      // Green/accent glow for valid empty cell
      drawHexagon(hPx.x, hPx.y, HEX_SIZE - 2, "rgba(126, 184, 218, 0.12)", "#7eb8da", 2.5);
      // Outer glow ring
      ctx.save();
      ctx.shadowColor = "rgba(126, 184, 218, 0.4)";
      ctx.shadowBlur = 12;
      drawHexagon(hPx.x, hPx.y, HEX_SIZE + 1, null, "rgba(126, 184, 218, 0.3)", 1.5);
      ctx.restore();
    }
  }

  // Reject flash overlay
  if (rejectFlashHex) {
    const elapsed = performance.now() - (rejectFlashHex.until - 400);
    const pulse = Math.sin(elapsed * 0.025) * 0.5 + 0.5; // oscillate 0..1
    const rPx = hexToPixel(rejectFlashHex.q, rejectFlashHex.r);
    const alpha = 0.1 + pulse * 0.2;
    drawHexagon(rPx.x, rPx.y, HEX_SIZE - 2, "rgba(216, 92, 92, " + alpha + ")", "#d85c5c", 2.5);
  }

  // Title above loom
  ctx.fillStyle = "#3a3a4a";
  ctx.font = "italic 11px Georgia, serif";
  ctx.textAlign = "center";
  ctx.fillText(getLoomLabel() + " (" + getHexPositions().length + " cells)", CENTER_X, canvas.height - 12);
}

// ============================================================
// ANIMATION OVERLAY RENDERER
// ============================================================

function drawAnimOverlay() {
  const o = animOverlay;

  // Charge glow at center
  if (o.chargeGlow > 0) {
    const radius = HEX_SIZE * 3 * o.chargeGlow;
    const grad = ctx.createRadialGradient(CENTER_X, CENTER_Y, 0, CENTER_X, CENTER_Y, radius);
    grad.addColorStop(0, "rgba(212, 168, 78, " + (0.25 * o.chargeGlow) + ")");
    grad.addColorStop(0.5, "rgba(126, 184, 218, " + (0.12 * o.chargeGlow) + ")");
    grad.addColorStop(1, "rgba(126, 184, 218, 0)");
    ctx.fillStyle = grad;
    ctx.fillRect(0, 0, canvas.width, canvas.height);
  }

  // All-hex vibrate (paradox) — offset each hex slightly
  if (o.allHexVibrate > 0) {
    const positions = loom.getPositions();
    for (const pos of positions) {
      if (!pos.thread) continue;
      const px = hexToPixel(pos.q, pos.r);
      const ox = (Math.random() - 0.5) * 4 * o.allHexVibrate;
      const oy = (Math.random() - 0.5) * 4 * o.allHexVibrate;
      drawHexagon(px.x + ox, px.y + oy, HEX_SIZE - 2, null, "rgba(216, 92, 92, " + (0.4 * o.allHexVibrate) + ")", 2.5);
    }
  }

  // Energy pulse along connection line
  if (o.energyPulse) {
    const p = o.energyPulse;
    const px = p.ax + (p.bx - p.ax) * p.progress;
    const py = p.ay + (p.by - p.ay) * p.progress;

    // Glowing trail line
    ctx.save();
    ctx.strokeStyle = p.color;
    ctx.lineWidth = 3;
    ctx.shadowColor = p.color;
    ctx.shadowBlur = 12;
    ctx.globalAlpha = 0.8;
    ctx.beginPath();
    const trailStart = Math.max(0, p.progress - 0.3);
    ctx.moveTo(p.ax + (p.bx - p.ax) * trailStart, p.ay + (p.by - p.ay) * trailStart);
    ctx.lineTo(px, py);
    ctx.stroke();
    ctx.restore();

    // Leading orb
    ctx.save();
    const orbGrad = ctx.createRadialGradient(px, py, 0, px, py, 10);
    orbGrad.addColorStop(0, p.color);
    orbGrad.addColorStop(1, "rgba(0,0,0,0)");
    ctx.fillStyle = orbGrad;
    ctx.globalAlpha = 0.9;
    ctx.fillRect(px - 10, py - 10, 20, 20);
    ctx.restore();
  }

  // Hex glows
  for (const g of o.hexGlows) {
    ctx.save();
    ctx.shadowColor = g.color;
    ctx.shadowBlur = 20;
    ctx.globalAlpha = g.alpha;
    drawHexagon(g.cx, g.cy, HEX_SIZE + 2, null, g.color, 3);
    // Inner fill glow — parse hex color to rgba
    const hc = g.color;
    const hr = parseInt(hc.slice(1,3), 16);
    const hg = parseInt(hc.slice(3,5), 16);
    const hb = parseInt(hc.slice(5,7), 16);
    const hGrad = ctx.createRadialGradient(g.cx, g.cy, 0, g.cx, g.cy, HEX_SIZE);
    hGrad.addColorStop(0, "rgba(" + hr + "," + hg + "," + hb + ",0.2)");
    hGrad.addColorStop(1, "rgba(0,0,0,0)");
    ctx.fillStyle = hGrad;
    ctx.shadowBlur = 0;
    ctx.fillRect(g.cx - HEX_SIZE, g.cy - HEX_SIZE, HEX_SIZE * 2, HEX_SIZE * 2);
    ctx.restore();
  }

  // Sparkle particles (resonance)
  for (const sp of o.sparkles) {
    ctx.save();
    ctx.globalAlpha = sp.alpha;
    ctx.fillStyle = sp.color;
    ctx.beginPath();
    // 4-pointed star
    const s = sp.size;
    ctx.moveTo(sp.x, sp.y - s);
    ctx.lineTo(sp.x + s * 0.3, sp.y - s * 0.3);
    ctx.lineTo(sp.x + s, sp.y);
    ctx.lineTo(sp.x + s * 0.3, sp.y + s * 0.3);
    ctx.lineTo(sp.x, sp.y + s);
    ctx.lineTo(sp.x - s * 0.3, sp.y + s * 0.3);
    ctx.lineTo(sp.x - s, sp.y);
    ctx.lineTo(sp.x - s * 0.3, sp.y - s * 0.3);
    ctx.closePath();
    ctx.fill();
    ctx.restore();
  }

  // Stability label at midpoint
  if (o.stabilityLabel) {
    const sl = o.stabilityLabel;
    ctx.save();
    ctx.globalAlpha = sl.alpha;
    ctx.font = "bold 11px 'Segoe UI', system-ui, sans-serif";
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    ctx.fillStyle = "#0a0a0f";
    ctx.fillText(sl.text.toUpperCase(), sl.x + 1, sl.y + 1);
    ctx.fillStyle = sl.color;
    ctx.fillText(sl.text.toUpperCase(), sl.x, sl.y);
    ctx.restore();
  }

  // Archetype name at midpoint
  if (o.archetypeName) {
    const an = o.archetypeName;
    ctx.save();
    ctx.globalAlpha = an.alpha;
    ctx.font = "bold 14px 'Segoe UI', system-ui, sans-serif";
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    // Tier color
    const tierColors = {
      common: "#c8c8d8", uncommon: "#5cb85c", rare: "#7eb8da",
      mythic: "#9b7ed8", legendary: "#d4a84e"
    };
    ctx.shadowColor = tierColors[an.tier] || "#c8c8d8";
    ctx.shadowBlur = 8;
    ctx.fillStyle = tierColors[an.tier] || "#c8c8d8";
    ctx.fillText(an.text, an.x, an.y);
    ctx.restore();
  }

  // Near-miss label at crossing midpoint
  if (o.nearMissLabel) {
    const nm = o.nearMissLabel;
    ctx.save();
    ctx.globalAlpha = nm.alpha;
    ctx.font = "italic 11px 'Segoe UI', system-ui, sans-serif";
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    ctx.fillStyle = "#0a0a0f";
    ctx.fillText(nm.text, nm.x + 1, nm.y + 1);
    ctx.fillStyle = nm.color;
    ctx.fillText(nm.text, nm.x, nm.y);
    ctx.restore();
  }

  // Flavor label (first-discovery ceremony)
  if (o.flavorLabel) {
    const fl = o.flavorLabel;
    ctx.save();
    ctx.globalAlpha = fl.alpha;
    ctx.font = "italic 11px 'Segoe UI', system-ui, sans-serif";
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    ctx.fillStyle = "#0a0a0f";
    ctx.fillText(fl.text, fl.x + 1, fl.y + 1);
    ctx.fillStyle = fl.color;
    ctx.shadowColor = fl.color;
    ctx.shadowBlur = 6;
    ctx.fillText(fl.text, fl.x, fl.y);
    ctx.restore();
  }

  // Discovery burst ring (first-discovery ceremony)
  if (o.discoveryBurst) {
    const db = o.discoveryBurst;
    ctx.save();
    ctx.globalAlpha = db.alpha;
    ctx.strokeStyle = db.color;
    ctx.lineWidth = 3;
    ctx.shadowColor = db.color;
    ctx.shadowBlur = 14;
    ctx.beginPath();
    ctx.arc(db.cx, db.cy, db.radius, 0, Math.PI * 2);
    ctx.stroke();
    // Inner fill glow
    const burstGrad = ctx.createRadialGradient(db.cx, db.cy, db.radius * 0.6, db.cx, db.cy, db.radius);
    burstGrad.addColorStop(0, "rgba(212, 168, 78, 0)");
    burstGrad.addColorStop(1, "rgba(212, 168, 78, " + (db.alpha * 0.15) + ")");
    ctx.fillStyle = burstGrad;
    ctx.shadowBlur = 0;
    ctx.beginPath();
    ctx.arc(db.cx, db.cy, db.radius, 0, Math.PI * 2);
    ctx.fill();
    ctx.restore();
  }

  // Cascade ripple
  if (o.cascadeRipple) {
    const cr = o.cascadeRipple;
    ctx.save();
    ctx.globalAlpha = cr.alpha;
    ctx.strokeStyle = cr.color;
    ctx.lineWidth = 2;
    ctx.shadowColor = cr.color;
    ctx.shadowBlur = 8;
    ctx.beginPath();
    ctx.arc(cr.cx, cr.cy, cr.radius, 0, Math.PI * 2);
    ctx.stroke();
    ctx.restore();
  }
}

// Helper: animate a property from start to end over durationMs using rAF
function animateProp(target, prop, from, to, durationMs) {
  return new Promise(resolve => {
    const startTime = performance.now();
    function tick(now) {
      const elapsed = now - startTime;
      const t = Math.min(elapsed / durationMs, 1);
      const eased = t < 0.5 ? 2 * t * t : 1 - Math.pow(-2 * t + 2, 2) / 2; // easeInOutQuad
      target[prop] = from + (to - from) * eased;
      drawLoom();
      drawAnimOverlay();
      if (t < 1) requestAnimationFrame(tick);
      else resolve();
    }
    requestAnimationFrame(tick);
  });
}

// Helper: run a custom animation loop for durationMs, calling onFrame(progress 0..1)
function animateCustom(durationMs, onFrame) {
  return new Promise(resolve => {
    const startTime = performance.now();
    function tick(now) {
      const elapsed = now - startTime;
      const t = Math.min(elapsed / durationMs, 1);
      onFrame(t);
      drawLoom();
      drawAnimOverlay();
      if (t < 1) requestAnimationFrame(tick);
      else resolve();
    }
    requestAnimationFrame(tick);
  });
}

// Helper: simple delay with redraw
function animDelay(ms) {
  return new Promise(resolve => setTimeout(resolve, ms));
}

// Spawn sparkle particles around a position
function spawnSparkles(cx, cy, color, count) {
  for (let i = 0; i < count; i++) {
    const angle = Math.random() * Math.PI * 2;
    const speed = 0.3 + Math.random() * 0.7;
    animOverlay.sparkles.push({
      x: cx + (Math.random() - 0.5) * HEX_SIZE * 0.8,
      y: cy + (Math.random() - 0.5) * HEX_SIZE * 0.8,
      vx: Math.cos(angle) * speed,
      vy: Math.sin(angle) * speed,
      alpha: 0.8 + Math.random() * 0.2,
      size: 2 + Math.random() * 3,
      color: color,
    });
  }
}

// Update and decay sparkles each frame
function tickSparkles() {
  for (const sp of animOverlay.sparkles) {
    sp.x += sp.vx;
    sp.y += sp.vy;
    sp.alpha *= 0.95;
    sp.size *= 0.97;
  }
  animOverlay.sparkles = animOverlay.sparkles.filter(sp => sp.alpha > 0.05);
}

// --- Screen shake (CSS transform, doesn't interfere with canvas draws) ---
function screenShake(intensity = 5, duration = 200) {
  const start = performance.now();
  function shake(t) {
    const elapsed = t - start;
    if (elapsed > duration) { canvas.style.transform = ""; return; }
    const decay = 1 - elapsed / duration;
    const dx = (Math.random() - 0.5) * intensity * decay * 2;
    const dy = (Math.random() - 0.5) * intensity * decay * 2;
    canvas.style.transform = `translate(${dx}px, ${dy}px)`;
    requestAnimationFrame(shake);
  }
  requestAnimationFrame(shake);
}

// --- Brightness flash (brief CSS filter pulse for cascade waves) ---
function brightFlash(duration = 200) {
  const start = performance.now();
  const prevFilter = canvas.style.filter || "";
  function flash(t) {
    const elapsed = t - start;
    if (elapsed > duration) {
      // Restore previous filter (saturation may still be active)
      canvas.style.filter = prevFilter;
      return;
    }
    const progress = elapsed / duration;
    const brightness = 1.3 - 0.3 * progress; // 1.3 -> 1.0
    // Preserve existing saturation if present
    const satMatch = prevFilter.match(/saturate\(([^)]+)\)/);
    const satPart = satMatch ? `saturate(${satMatch[1]})` : "";
    canvas.style.filter = `${satPart} brightness(${brightness})`.trim();
    requestAnimationFrame(flash);
  }
  requestAnimationFrame(flash);
}

// ============================================================
// ANIMATED ACTIVATION SEQUENCE
// ============================================================

async function runActivationAnimation(crossings) {
  const activateBtn = document.getElementById("activateBtn");
  const resetBtn = document.getElementById("resetBtn");
  const trayEl = document.getElementById("threadTray");
  const trayLabel = document.querySelector(".tray-label");
  const hintEl = document.getElementById("hintText");
  const resultsPanel = document.getElementById("resultsPanel");

  // --- Phase 0: Lock UI ---
  loomLocked = true;
  activateBtn.classList.add("btn-locked");
  resetBtn.classList.add("btn-locked");
  trayEl.classList.add("tray-dimmed");
  if (trayLabel) trayLabel.style.opacity = "0.3";
  hintEl.textContent = "The loom stirs...";
  selectedTrayIndex = null;

  // --- Audio: lever pull ---
  GameAudio.init();
  GameAudio.leverPull();

  // --- Phase 1: Charge-up glow (500ms) ---
  await animateProp(animOverlay, "chargeGlow", 0, 1, 500);

  // Hold briefly then dim
  await animDelay(100);
  await animateProp(animOverlay, "chargeGlow", 1, 0.15, 200);

  // --- Phase 2: Sequential crossing resolution ---
  const cascadeEscalation = (index) => 1 + index * 0.3;
  for (let i = 0; i < crossings.length; i++) {
    const cx = crossings[i];
    const stability = cx.unification.stability;
    const vfx = STABILITY_VFX[stability];

    // Cascade depth escalation: saturation ramps with each crossing
    const sat = Math.min(1.0 + i * 0.15, 2.0);
    const satValue = stability === "paradox" ? Math.max(sat, 1.8) : sat;
    canvas.style.filter = `saturate(${satValue.toFixed(2)})`;

    const pxA = hexToPixel(cx.threadA.position.q, cx.threadA.position.r);
    const pxB = hexToPixel(cx.threadB.position.q, cx.threadB.position.r);
    const midX = (pxA.x + pxB.x) / 2;
    const midY = (pxA.y + pxB.y) / 2;

    // --- 2a: Energy pulse along connection line (300ms) ---
    animOverlay.energyPulse = {
      ax: pxA.x, ay: pxA.y,
      bx: pxB.x, by: pxB.y,
      progress: 0,
      color: vfx.color,
    };
    await animateCustom(300, (t) => {
      animOverlay.energyPulse.progress = t;
      tickSparkles();
    });
    animOverlay.energyPulse = null;

    // --- 2b: Both hexes glow (200ms) ---
    animOverlay.hexGlows = [
      { cx: pxA.x, cy: pxA.y, alpha: 0, color: vfx.color },
      { cx: pxB.x, cy: pxB.y, alpha: 0, color: vfx.color },
    ];

    // Stability-specific effects (with cascade escalation)
    const escalation = cascadeEscalation(i);
    if (stability === "resonance") {
      spawnSparkles(pxA.x, pxA.y, vfx.color, 8);
      spawnSparkles(pxB.x, pxB.y, vfx.color, 8);
      screenShake(1 * escalation, 100);
    }
    if (stability === "tension") {
      screenShake(3 * escalation, 200);
    }
    if (stability === "paradox") {
      document.getElementById("paradoxVignette").classList.add("active");
      animOverlay.allHexVibrate = 0;
      screenShake(8 * escalation, 400);
    }

    // --- Audio: stability tone ---
    if (GameAudio[stability]) GameAudio[stability]();

    await animateCustom(200, (t) => {
      const peak = t < 0.5 ? t * 2 : 2 - t * 2; // triangle wave: ramp up then down
      for (const g of animOverlay.hexGlows) g.alpha = peak * 0.8;
      if (stability === "paradox") animOverlay.allHexVibrate = peak;
      tickSparkles();
    });

    if (stability === "paradox") {
      animOverlay.allHexVibrate = 0;
      // Keep vignette a moment then fade
      setTimeout(() => {
        document.getElementById("paradoxVignette").classList.remove("active");
      }, 400);
    }
    animOverlay.hexGlows = [];

    // --- 2c: Stability label appears at midpoint (100ms visible) ---
    animOverlay.stabilityLabel = {
      x: midX, y: midY - 18,
      text: stability,
      alpha: 0,
      color: vfx.color,
    };
    await animateCustom(100, (t) => {
      animOverlay.stabilityLabel.alpha = t;
      tickSparkles();
    });
    // Hold visible briefly
    await animateCustom(200, (t) => {
      animOverlay.stabilityLabel.alpha = 1 - t * 0.3;
      tickSparkles();
    });

    // --- 2d: Archetype name fades in (200ms) ---
    if (cx.archetype.match) {
      // Record discovery in codex
      const catalogEntry = CATALOG.find(a => a.name === cx.archetype.match.name);
      const requiredTraits = catalogEntry
        ? Object.keys(catalogEntry.required).filter(k => k !== "_minConflicts")
        : [];
      const isNewDiscovery = Codex.discover(codexData, cx.archetype.match, { requiredTraits });
      updateCodexBtnCount();

      // Track in run state
      if (runState.active) {
        runState.producedArchetypes.push({ name: cx.archetype.match.name, tier: cx.archetype.match.tier });
        runState.cycleArchetypes.push({ name: cx.archetype.match.name, tier: cx.archetype.match.tier });
        if (isNewDiscovery) runState.newDiscoveries++;
      }

      // --- Audio: archetype match ---
      GameAudio.archetypeMatch();

      animOverlay.archetypeName = {
        x: midX, y: midY + 2,
        text: cx.archetype.match.name,
        alpha: 0,
        tier: cx.archetype.match.tier,
      };

      if (isNewDiscovery) {
        // --- Audio: first discovery ---
        GameAudio.discovery();

        // --- First Discovery Ceremony ---
        const fullName = cx.archetype.match.name;
        const flavorText = cx.archetype.match.flavor || "";

        // 1. Radial burst from crossing point
        animOverlay.discoveryBurst = {
          cx: midX, cy: midY,
          radius: 4,
          maxRadius: HEX_SIZE * 3,
          alpha: 0.9,
          color: "#d4a84e",
        };
        spawnSparkles(midX, midY, "#d4a84e", 12);
        await animateCustom(400, (t) => {
          const db = animOverlay.discoveryBurst;
          db.radius = 4 + t * (db.maxRadius - 4);
          db.alpha = 0.9 * (1 - t * 0.7);
          tickSparkles();
        });
        animOverlay.discoveryBurst = null;

        // 2. Letter-by-letter name reveal in gold
        await animateCustom(600, (t) => {
          const charCount = Math.ceil(t * fullName.length);
          animOverlay.archetypeName.text = fullName.substring(0, charCount);
          animOverlay.archetypeName.alpha = 1;
          tickSparkles();
        });

        // 3. Flavor text fades in below
        if (flavorText) {
          animOverlay.flavorLabel = {
            x: midX, y: midY + 22,
            text: flavorText,
            alpha: 0,
            color: "rgba(212, 168, 78, 0.85)",
          };
          await animateCustom(400, (t) => {
            animOverlay.flavorLabel.alpha = t * 0.85;
            tickSparkles();
          });
        }

        // 4. Hold ceremony visible (total ~1.5s with above)
        spawnSparkles(midX, midY, "#d4a84e", 6);
        await animateCustom(600, (t) => {
          tickSparkles();
        });

        // 5. Pulse the codex button
        const codexBtn = document.getElementById("codexBtn");
        codexBtn.classList.add("discovery-pulse");
        setTimeout(() => codexBtn.classList.remove("discovery-pulse"), 1800);

        // Fade out ceremony elements
        await animateCustom(400, (t) => {
          animOverlay.archetypeName.alpha = 1 - t;
          if (animOverlay.flavorLabel) animOverlay.flavorLabel.alpha = 0.85 * (1 - t);
          if (animOverlay.stabilityLabel) animOverlay.stabilityLabel.alpha = Math.max(0, 0.7 - t);
          tickSparkles();
        });
        animOverlay.flavorLabel = null;
      } else {
        // --- Standard animation (repeat discovery) ---
        await animateCustom(200, (t) => {
          animOverlay.archetypeName.alpha = t;
          tickSparkles();
        });

        // Hold archetype name visible
        await animateCustom(300, (t) => {
          animOverlay.archetypeName.alpha = 1 - t * 0.5;
          if (animOverlay.stabilityLabel) animOverlay.stabilityLabel.alpha = Math.max(0, 0.7 - t);
          tickSparkles();
        });
      }

      // --- 2e: Cascade wave if archetype has cascade traits (200ms) ---
      const cascadeTraits = Object.keys(cx.archetype.match.cascade || {});
      if (cascadeTraits.length > 0) {
        animOverlay.cascadeRipple = {
          cx: midX, cy: midY,
          radius: 5,
          maxRadius: HEX_SIZE * 2.5,
          alpha: 0.8,
          color: "#d4a84e",
        };
        // Cascade chain brightness flash
        brightFlash(200);
        await animateCustom(300, (t) => {
          const cr = animOverlay.cascadeRipple;
          cr.radius = 5 + t * (cr.maxRadius - 5);
          cr.alpha = 0.8 * (1 - t);
          tickSparkles();
        });
        animOverlay.cascadeRipple = null;
      }
    } else {
      // No match — just fade stability label
      await animateCustom(200, (t) => {
        if (animOverlay.stabilityLabel) animOverlay.stabilityLabel.alpha = Math.max(0, 0.7 - t);
        tickSparkles();
      });

      // --- Near-miss ambient signal (no archetype matched) ---
      if (cx.archetype.nearMisses && cx.archetype.nearMisses.length > 0) {
        const bestNM = cx.archetype.nearMisses[0];
        const strong = bestNM.ratio >= 0.75;
        const nmTierColors = {
          common: "#8a8a6a", uncommon: "#4a8a4a", rare: "#5a8aaa",
          mythic: "#7a5aaa", legendary: "#b89040"
        };
        const nmColor = strong ? "#d4a84e" : "rgba(212, 168, 78, 0.6)";
        const nmSparkleColor = nmTierColors[bestNM.tier] || "#8a8a6a";
        const nmText = strong ? "Almost there..." : "Something stirs...";
        const nmSparkleCount = strong ? 5 : 3;

        // Brief color flash on the crossing hex glows
        animOverlay.hexGlows = [
          { cx: pxA.x, cy: pxA.y, alpha: 0, color: nmSparkleColor },
          { cx: pxB.x, cy: pxB.y, alpha: 0, color: nmSparkleColor },
        ];
        await animateCustom(150, (t) => {
          const flash = t < 0.5 ? t * 2 : 2 - t * 2;
          for (const g of animOverlay.hexGlows) g.alpha = flash * (strong ? 0.4 : 0.2);
          tickSparkles();
        });
        animOverlay.hexGlows = [];

        // Subtle sparkle motes
        spawnSparkles(midX, midY, nmSparkleColor, nmSparkleCount);

        // Near-miss text fades in and out over ~1s
        animOverlay.nearMissLabel = {
          x: midX, y: midY + 20,
          text: nmText,
          alpha: 0,
          color: nmColor,
        };
        // Fade in (200ms)
        await animateCustom(200, (t) => {
          animOverlay.nearMissLabel.alpha = t * (strong ? 0.9 : 0.6);
          tickSparkles();
        });
        // Hold (400ms)
        await animateCustom(400, (t) => {
          animOverlay.nearMissLabel.alpha = (strong ? 0.9 : 0.6);
          tickSparkles();
        });
        // Fade out (400ms)
        await animateCustom(400, (t) => {
          animOverlay.nearMissLabel.alpha = (strong ? 0.9 : 0.6) * (1 - t);
          tickSparkles();
        });
        animOverlay.nearMissLabel = null;
      }
    }

    // Clear overlay labels for next crossing
    animOverlay.stabilityLabel = null;
    animOverlay.archetypeName = null;

    // Brief gap before next crossing (unless last)
    if (i < crossings.length - 1) {
      await animateCustom(200, (t) => { tickSparkles(); });
    }
  }

  // --- Phase 3: Final pause and show results ---
  // Reset canvas visual effects (saturation, brightness)
  canvas.style.filter = "";
  canvas.style.transform = "";

  // Fade out charge glow completely
  await animateProp(animOverlay, "chargeGlow", animOverlay.chargeGlow, 0, 300);

  // Wait for remaining sparkles
  await animateCustom(200, (t) => { tickSparkles(); });
  animOverlay.sparkles = [];

  // Render results panel with fade-in
  renderResults(crossings);
  resultsPanel.classList.add("fade-in");

  // Re-enable action button (hide reset during run — use results panel buttons instead)
  if (runState.active) {
    resetBtn.style.display = "none";
    hintEl.textContent = "Crossing complete. See results below.";
  } else {
    resetBtn.classList.remove("btn-locked");
    hintEl.textContent = "Crossing complete. Reset to weave again.";
  }

  // Check if codex discoveries warrant a loom expansion
  const nextTier = computeLoomTier();
  if (nextTier !== currentLoomTier) {
    // Show expansion message -- the actual upgrade happens on next startWeave()
    showLoomExpandedMessage(currentLoomTier, nextTier);
    currentLoomTier = nextTier;
  }
}

// ============================================================
// THREAD TRAY
// ============================================================

function renderTray() {
  const tray = document.getElementById("threadTray");
  tray.innerHTML = "";

  if (trayThreads.length === 0) {
    tray.innerHTML = '<span class="hint">No threads in tray. Reset to start over.</span>';
    return;
  }

  trayThreads.forEach((thread, idx) => {
    const card = document.createElement("div");
    card.className = "thread-card" + (selectedTrayIndex === idx ? " selected" : "");

    const header = document.createElement("div");
    const nameSpan = document.createElement("span");
    nameSpan.className = "card-name";
    nameSpan.textContent = thread.name;
    header.appendChild(nameSpan);

    const raritySpan = document.createElement("span");
    raritySpan.className = "card-rarity rarity-" + thread.rarity;
    raritySpan.textContent = thread.rarity;
    header.appendChild(raritySpan);
    card.appendChild(header);

    const traitsDiv = document.createElement("div");
    traitsDiv.className = "card-traits";
    for (const trait of Object.keys(thread.nature)) {
      const tag = document.createElement("span");
      tag.className = "trait-tag";
      tag.textContent = trait;
      tag.style.borderColor = TRAIT_COLORS[trait] || "rgba(126, 184, 218, 0.15)";
      tag.style.color = TRAIT_COLORS[trait] || "#5cd8d8";
      traitsDiv.appendChild(tag);
    }
    card.appendChild(traitsDiv);

    // Drag-and-drop via pointer events
    let dragStartX = 0, dragStartY = 0, isDragging = false;
    const DRAG_THRESHOLD = 5;

    card.addEventListener("pointerdown", (e) => {
      if (e.button !== 0) return; // left button only
      dragStartX = e.clientX;
      dragStartY = e.clientY;
      isDragging = false;
      card.setPointerCapture(e.pointerId);
    });

    card.addEventListener("pointermove", (e) => {
      if (!card.hasPointerCapture(e.pointerId)) return;
      const dx = e.clientX - dragStartX;
      const dy = e.clientY - dragStartY;
      if (!isDragging && Math.sqrt(dx * dx + dy * dy) > DRAG_THRESHOLD) {
        isDragging = true;
        startDrag(idx, e.clientX, e.clientY);
      }
      if (isDragging) {
        moveDrag(e.clientX, e.clientY);
      }
    });

    card.addEventListener("pointerup", (e) => {
      if (isDragging) {
        endDrag(e.clientX, e.clientY);
        isDragging = false;
      } else {
        // Click behavior: toggle selection
        if (selectedTrayIndex === idx) {
          selectedTrayIndex = null;
        } else {
          selectedTrayIndex = idx;
        }
        renderTray();
        updateHint();
      }
    });

    card.addEventListener("pointercancel", () => {
      if (isDragging) {
        cancelDrag();
        isDragging = false;
      }
    });

    tray.appendChild(card);
  });
}

function updateHint() {
  const hint = document.getElementById("hintText");
  if (dragState) {
    hint.textContent = "Drop " + trayThreads[dragState.threadIndex].name + " on an empty hex.";
  } else if (selectedTrayIndex !== null) {
    hint.textContent = "Click an empty hex on the loom to place " + trayThreads[selectedTrayIndex].name + ".";
  } else if (trayThreads.length > 0) {
    hint.textContent = "Drag a thread to the loom, or click to select then click a hex.";
  } else {
    hint.textContent = "All threads placed. Pull the Lever to activate!";
  }
}

// ============================================================
// CANVAS CLICK HANDLER
// ============================================================

canvas.addEventListener("click", (e) => {
  // Route click based on game phase
  if (gamePhase === "wander") {
    handleMapClick(e.clientX, e.clientY);
    return;
  }

  // Weave phase: loom placement
  if (loomLocked) return;
  if (selectedTrayIndex === null) return;

  const rect = canvas.getBoundingClientRect();
  const mx = e.clientX - rect.left;
  const my = e.clientY - rect.top;

  // Find which hex was clicked (point-in-hex test)
  for (const pos of getHexPositions()) {
    const px = hexToPixel(pos.q, pos.r);
    const dist = Math.sqrt((mx - px.x) ** 2 + (my - px.y) ** 2);

    if (dist < HEX_SIZE - 5) {
      const key = posKey(pos.q, pos.r);
      if (loom.grid.has(key)) {
        // Already occupied — flash red
        triggerRejectFlash(pos.q, pos.r);
        return;
      }

      // Place the thread
      const thread = trayThreads[selectedTrayIndex];
      loom.place(thread, pos.q, pos.r);
      trayThreads.splice(selectedTrayIndex, 1);
      selectedTrayIndex = null;
      lastCrossings = null;
      document.getElementById("resultsPanel").style.display = "none";

      drawLoom();
      renderTray();
      updateHint();
      return;
    }
  }
});

// ============================================================
// ACTIVATE BUTTON
// ============================================================

document.getElementById("activateBtn").addEventListener("click", () => {
  if (loomLocked) return;

  // Need at least one crossing (2 adjacent threads)
  let hasAdjacentPair = false;
  for (const pos of loom.getPositions()) {
    if (pos.thread) {
      const neighbors = loom.getNeighbors(pos.q, pos.r);
      if (neighbors.length > 0) {
        hasAdjacentPair = true;
        break;
      }
    }
  }

  if (!hasAdjacentPair) {
    document.getElementById("hintText").textContent = "Place at least two adjacent threads to activate.";
    return;
  }

  // Compute all crossings instantly (engine unchanged), then animate display
  lastCrossings = loom.activate();
  runActivationAnimation(lastCrossings);
});

// ============================================================
// RESULTS RENDERER
// ============================================================

function renderResults(crossings) {
  const panel = document.getElementById("resultsPanel");
  const content = document.getElementById("resultsContent");
  content.innerHTML = "";

  // Cycle header (if run is active)
  if (runState.active) {
    const cycleHeader = document.createElement("div");
    cycleHeader.className = "results-cycle-header";
    cycleHeader.textContent = "Cycle " + runState.cycle + " of " + runState.maxCycles;
    content.appendChild(cycleHeader);
  }

  if (crossings.length === 0) {
    content.innerHTML += '<div class="no-match">No crossings to resolve.</div>';
    appendResultsActions(content);
    panel.style.display = "block";
    return;
  }

  for (const crossing of crossings) {
    const div = document.createElement("div");
    div.className = "crossing-result";

    // Header: Thread A x Thread B
    const header = document.createElement("div");
    header.className = "crossing-header";
    header.innerHTML =
      '<span class="thread-name">' + crossing.threadA.name + '</span>' +
      ' (' + crossing.threadA.position.q + ',' + crossing.threadA.position.r + ')' +
      ' x ' +
      '<span class="thread-name">' + crossing.threadB.name + '</span>' +
      ' (' + crossing.threadB.position.q + ',' + crossing.threadB.position.r + ')';
    div.appendChild(header);

    // Stability badge
    const stability = crossing.unification.stability;
    const badge = document.createElement("span");
    badge.className = "stability-badge stability-" + stability;
    badge.textContent = stability;
    div.appendChild(badge);

    // Archetype match
    if (crossing.archetype.match) {
      const matchDiv = document.createElement("div");
      matchDiv.className = "crossing-match";
      matchDiv.style.marginTop = "0.4rem";

      const nameSpan = document.createElement("span");
      nameSpan.className = "match-name";
      nameSpan.textContent = crossing.archetype.match.name;
      matchDiv.appendChild(nameSpan);

      const tierSpan = document.createElement("span");
      tierSpan.className = "match-tier tier-" + crossing.archetype.match.tier;
      tierSpan.textContent = crossing.archetype.match.tier;
      matchDiv.appendChild(tierSpan);

      if (crossing.archetype.score) {
        const scoreSpan = document.createElement("span");
        scoreSpan.style.cssText = "font-family: monospace; font-size: 0.7rem; color: #6e6e8e;";
        scoreSpan.textContent = crossing.archetype.score.matched + "/" + crossing.archetype.score.total;
        matchDiv.appendChild(scoreSpan);
      }

      div.appendChild(matchDiv);

      // Flavor text
      const flavorDiv = document.createElement("div");
      flavorDiv.className = "match-flavor";
      flavorDiv.textContent = crossing.archetype.match.flavor;
      div.appendChild(flavorDiv);

      // Cascade info
      const cascadeTraits = Object.keys(crossing.archetype.match.cascade || {});
      if (cascadeTraits.length > 0) {
        const cascadeDiv = document.createElement("div");
        cascadeDiv.className = "cascade-info";
        cascadeDiv.textContent = "cascade: {" + cascadeTraits.join(", ") + "}";
        div.appendChild(cascadeDiv);
      }
    } else {
      const noMatch = document.createElement("div");
      noMatch.className = "no-match";
      noMatch.textContent = "No archetype matched.";
      noMatch.style.marginTop = "0.4rem";
      div.appendChild(noMatch);
    }

    // Cascade applied indicators
    if (crossing.cascadeApplied && crossing.cascadeApplied.length > 0) {
      const appliedDiv = document.createElement("div");
      appliedDiv.className = "cascade-info";
      appliedDiv.style.color = "#9b7ed8";
      const traitNames = [...new Set(crossing.cascadeApplied.map(c => c.trait))];
      appliedDiv.textContent = "received cascade: {" + traitNames.join(", ") + "}";
      div.appendChild(appliedDiv);
    }

    // Near-misses
    if (crossing.archetype.nearMisses && crossing.archetype.nearMisses.length > 0) {
      const nmDiv = document.createElement("div");
      nmDiv.className = "near-misses";

      for (const nm of crossing.archetype.nearMisses) {
        const nmLine = document.createElement("div");
        nmLine.className = "near-miss";
        nmLine.innerHTML =
          '<span class="nm-name">' + nm.name + '</span>' +
          ' (' + nm.tier + ') ' +
          nm.matched + '/' + nm.total +
          (nm.missingTraits.length > 0 ? ' — missing: ' + nm.missingTraits.join(', ') : '');
        nmDiv.appendChild(nmLine);
      }

      div.appendChild(nmDiv);
    }

    content.appendChild(div);
  }

  // Codex progress summary
  const codexDiv = document.createElement("div");
  codexDiv.style.cssText = "text-align: center; margin-top: 0.8rem; font-size: 0.75rem; color: #6e6e8e; font-style: italic;";
  const discovered = Object.keys(codexData.discovered).length;
  codexDiv.textContent = "Codex: " + discovered + " / " + CATALOG.length + " discovered";
  content.appendChild(codexDiv);

  // Run progress and cycle actions
  appendResultsActions(content);

  panel.style.display = "block";
}

function appendResultsActions(container) {
  if (!runState.active) return;

  // Cumulative run progress
  const progressDiv = document.createElement("div");
  progressDiv.className = "results-run-progress";
  const uniqueNames = [...new Set(runState.producedArchetypes.map(a => a.name))];
  progressDiv.textContent = "Run progress: " + runState.producedArchetypes.length + " archetypes produced" +
    (uniqueNames.length > 0 ? " (" + uniqueNames.length + " unique)" : "");
  container.appendChild(progressDiv);

  // Action buttons
  const actions = document.createElement("div");
  actions.className = "results-actions";

  if (runState.cycle < runState.maxCycles) {
    const nextBtn = document.createElement("button");
    nextBtn.className = "btn btn-primary";
    nextBtn.textContent = "Next Cycle";
    nextBtn.addEventListener("click", () => {
      nextCycle();
    });
    actions.appendChild(nextBtn);

    const endEarlyBtn = document.createElement("button");
    endEarlyBtn.className = "btn";
    endEarlyBtn.textContent = "End Run";
    endEarlyBtn.addEventListener("click", () => {
      endRun();
    });
    actions.appendChild(endEarlyBtn);
  } else {
    const endBtn = document.createElement("button");
    endBtn.className = "btn btn-primary";
    endBtn.textContent = "End Run";
    endBtn.addEventListener("click", () => {
      endRun();
    });
    actions.appendChild(endBtn);
  }

  container.appendChild(actions);
}

// ============================================================
// CROSSING HOVER PREVIEW
// ============================================================

const crossingTooltip = document.getElementById("crossingTooltip");
let tooltipVisible = false;

// Build list of crossing midpoints from current loom state
function getCrossingMidpoints() {
  const midpoints = [];
  const positions = loom.getPositions();
  const seen = new Set();

  for (const posA of positions) {
    if (!posA.thread) continue;
    for (const posB of positions) {
      if (!posB.thread) continue;
      if (posA.q === posB.q && posA.r === posB.r) continue;

      const dq = posB.q - posA.q;
      const dr = posB.r - posA.r;
      const isAdj = HEX_DIRS.some(d => d.q === dq && d.r === dr);
      if (!isAdj) continue;

      const keyA = posKey(posA.q, posA.r);
      const keyB = posKey(posB.q, posB.r);
      const pk = keyA < keyB ? keyA + "|" + keyB : keyB + "|" + keyA;
      if (seen.has(pk)) continue;
      seen.add(pk);

      const pxA = hexToPixel(posA.q, posA.r);
      const pxB = hexToPixel(posB.q, posB.r);

      midpoints.push({
        mx: (pxA.x + pxB.x) / 2,
        my: (pxA.y + pxB.y) / 2,
        threadA: posA.thread,
        threadB: posB.thread,
      });
    }
  }
  return midpoints;
}

function buildTooltipContent(threadA, threadB) {
  const natureA = threadA.nature;
  const natureB = threadB.nature;
  const result = unify(natureA, natureB);

  // Build per-trait classification
  const allTraits = Object.keys(result.unified);
  const resSet = new Set(result.resonances);
  const conSet = new Set(result.conflicts);
  const keysA = new Set(Object.keys(natureA));
  const keysB = new Set(Object.keys(natureB));

  let html = '<div class="ct-header">' + threadA.name + ' &times; ' + threadB.name + '</div>';

  for (const trait of allTraits) {
    const color = TRAIT_COLORS[trait] || "#6e6e8e";
    let tag = "";
    let tagClass = "ct-tag";

    if (resSet.has(trait)) {
      tag = "resonance";
      tagClass = "ct-tag ct-tag-resonance";
    } else if (conSet.has(trait)) {
      tag = "conflict";
      tagClass = "ct-tag ct-tag-conflict";
    } else if (keysA.has(trait) && !keysB.has(trait)) {
      tag = "unique";
    } else if (keysB.has(trait) && !keysA.has(trait)) {
      tag = "unique";
    } else {
      tag = "unique";
    }

    html += '<div class="ct-trait">';
    html += '<span class="ct-dot" style="background:' + color + '"></span>';
    html += '<span class="ct-name" style="color:' + color + '">' + trait + '</span>';
    html += '<span class="' + tagClass + '">' + tag + '</span>';
    html += '</div>';
  }

  // Stability classification
  const stabColors = {
    harmony: "#5cb85c",
    resonance: "#5cd8d8",
    tension: "#d4d84e",
    paradox: "#d85c5c",
  };
  const stabColor = stabColors[result.stability] || "#c8c8d8";
  html += '<div class="ct-stability" style="color:' + stabColor + '">';
  html += '&rarr; ' + result.stability;
  html += '</div>';

  return html;
}

canvas.addEventListener("mousemove", (e) => {
  // Skip tooltip during Wander phase
  if (gamePhase !== "weave") {
    if (tooltipVisible) {
      crossingTooltip.classList.remove("visible");
      tooltipVisible = false;
    }
    return;
  }
  if (loomLocked) {
    if (tooltipVisible) {
      crossingTooltip.classList.remove("visible");
      tooltipVisible = false;
    }
    return;
  }

  const rect = canvas.getBoundingClientRect();
  const scaleX = canvas.width / rect.width;
  const scaleY = canvas.height / rect.height;
  const mx = (e.clientX - rect.left) * scaleX;
  const my = (e.clientY - rect.top) * scaleY;

  const HOVER_RADIUS = 25;
  const midpoints = getCrossingMidpoints();
  let closest = null;
  let closestDist = Infinity;

  for (const mp of midpoints) {
    const dist = Math.sqrt((mx - mp.mx) ** 2 + (my - mp.my) ** 2);
    if (dist < HOVER_RADIUS && dist < closestDist) {
      closest = mp;
      closestDist = dist;
    }
  }

  if (closest) {
    // Position tooltip near the midpoint, offset to avoid obscuring hexes
    // Convert canvas coords back to CSS coords relative to the container
    const cssX = closest.mx / scaleX;
    const cssY = closest.my / scaleY;

    crossingTooltip.innerHTML = buildTooltipContent(closest.threadA, closest.threadB);

    // Position: offset 15px right and 10px up from midpoint
    const offsetX = 15;
    const offsetY = -10;
    let left = cssX + offsetX;
    let top = cssY + offsetY;

    // Keep tooltip within canvas bounds (right edge check)
    const tooltipWidth = 220; // approximate max width
    if (left + tooltipWidth > rect.width) {
      left = cssX - tooltipWidth - offsetX;
    }
    // Top edge check
    if (top < 0) {
      top = cssY + 15;
    }

    crossingTooltip.style.left = left + "px";
    crossingTooltip.style.top = top + "px";

    if (!tooltipVisible) {
      crossingTooltip.classList.add("visible");
      tooltipVisible = true;
    }
  } else {
    if (tooltipVisible) {
      crossingTooltip.classList.remove("visible");
      tooltipVisible = false;
    }
  }
});

canvas.addEventListener("mouseleave", () => {
  if (tooltipVisible) {
    crossingTooltip.classList.remove("visible");
    tooltipVisible = false;
  }
});

// ============================================================
// RESET
// ============================================================

document.getElementById("resetBtn").addEventListener("click", () => {
  if (runState.active) {
    // During a run, reset just the loom (re-enter weave with random threads)
    startWeave([]);
  } else {
    initGame();
  }
});

document.getElementById("wanderBtn").addEventListener("click", () => {
  startWander();
});

document.getElementById("returnLoomBtn").addEventListener("click", () => {
  if (wanderSatchel.length === 0) {
    if (!confirm("No threads collected \u2014 return anyway?")) return;
  }
  startWeave(wanderSatchel);
});

// Close thread draft overlay when clicking outside the panel
document.getElementById("threadDraftOverlay").addEventListener("click", function(e) {
  if (e.target === this) closeDraft();
});

// Close shrine overlay when clicking outside the panel
document.getElementById("shrineOverlay").addEventListener("click", function(e) {
  if (e.target === this) closeShrineOverlay();
});

// ============================================================
// CODEX — persistent discovery tracking via localStorage
// ============================================================

const Codex = {
  KEY: "tink-codex-v1",

  load() {
    const raw = localStorage.getItem(this.KEY);
    return raw ? JSON.parse(raw) : { discovered: {}, hints: {}, stats: { runs: 0, totalDiscoveries: 0 } };
  },

  save(codex) {
    localStorage.setItem(this.KEY, JSON.stringify(codex));
  },

  discover(codex, archetype, crossingDetails) {
    const isNew = !(archetype.name in codex.discovered);
    codex.discovered[archetype.name] = {
      name: archetype.name,
      tier: archetype.tier,
      flavor: archetype.flavor,
      firstDiscovered: codex.discovered[archetype.name]?.firstDiscovered || Date.now(),
      timesProduced: (codex.discovered[archetype.name]?.timesProduced || 0) + 1,
      requiredTraits: crossingDetails.requiredTraits,
    };
    if (isNew) codex.stats.totalDiscoveries++;
    this.save(codex);
    return isNew;
  },

  addHint(codex, hintText, archetypeName) {
    codex.hints[archetypeName] = { text: hintText, found: Date.now() };
    this.save(codex);
  },

  getCompletionRatio(codex, totalArchetypes) {
    return Object.keys(codex.discovered).length / totalArchetypes;
  },
};

let codexData = Codex.load();

// ============================================================
// CODEX UI — toggleable discovery panel
// ============================================================

const TIER_ORDER = ["common", "uncommon", "rare", "mythic", "legendary"];

function traitBadgeColor(trait) {
  let hash = 0;
  for (let i = 0; i < trait.length; i++) {
    hash = trait.charCodeAt(i) + ((hash << 5) - hash);
  }
  const hue = ((hash % 360) + 360) % 360;
  return { bg: "hsla(" + hue + ", 40%, 30%, 0.25)", border: "hsla(" + hue + ", 45%, 50%, 0.4)", color: "hsl(" + hue + ", 45%, 70%)" };
}

function updateCodexBtnCount() {
  const countEl = document.getElementById("codexBtnCount");
  if (countEl) {
    const n = Object.keys(codexData.discovered).length;
    countEl.textContent = n + "/" + CATALOG.length;
  }
}

function renderCodexPanel() {
  const panel = document.getElementById("codexPanel");
  panel.innerHTML = "";

  const discovered = Object.keys(codexData.discovered).length;
  const total = CATALOG.length;

  // Header
  const header = document.createElement("div");
  header.className = "codex-panel-header";

  const titleRow = document.createElement("div");
  const title = document.createElement("div");
  title.className = "codex-panel-title";
  title.textContent = "Codex";
  const progress = document.createElement("div");
  progress.className = "codex-panel-progress";
  progress.textContent = discovered + " of " + total + " archetypes discovered";
  titleRow.appendChild(title);
  titleRow.appendChild(progress);

  const closeBtn = document.createElement("button");
  closeBtn.className = "codex-close-btn";
  closeBtn.innerHTML = "&#x2715;";
  closeBtn.addEventListener("click", toggleCodex);

  header.appendChild(titleRow);
  header.appendChild(closeBtn);
  panel.appendChild(header);

  // Group by tier
  const grouped = {};
  for (const tier of TIER_ORDER) grouped[tier] = [];
  for (const arch of CATALOG) {
    if (grouped[arch.tier]) grouped[arch.tier].push(arch);
  }

  for (const tier of TIER_ORDER) {
    const archetypes = grouped[tier];
    if (archetypes.length === 0) continue;

    const group = document.createElement("div");
    group.className = "codex-tier-group";

    const tierHeader = document.createElement("div");
    tierHeader.className = "codex-tier-header tier-h-" + tier;
    const discoveredInTier = archetypes.filter(a => a.name in codexData.discovered).length;
    tierHeader.innerHTML = tier + '<span class="codex-tier-count">' + discoveredInTier + " / " + archetypes.length + "</span>";
    group.appendChild(tierHeader);

    const entries = document.createElement("div");
    entries.className = "codex-entries";

    for (const arch of archetypes) {
      const entry = document.createElement("div");
      const disc = codexData.discovered[arch.name];

      if (disc) {
        // Discovered entry
        entry.className = "codex-entry discovered tier-e-" + tier;

        const nameRow = document.createElement("div");
        const nameSpan = document.createElement("span");
        nameSpan.className = "codex-entry-name";
        nameSpan.textContent = arch.name;
        const tierSpan = document.createElement("span");
        tierSpan.className = "codex-entry-tier tier-" + tier;
        tierSpan.textContent = tier;
        nameRow.appendChild(nameSpan);
        nameRow.appendChild(tierSpan);
        entry.appendChild(nameRow);

        const flavor = document.createElement("div");
        flavor.className = "codex-entry-flavor";
        flavor.textContent = arch.flavor;
        entry.appendChild(flavor);

        // Trait badges
        if (disc.requiredTraits && disc.requiredTraits.length > 0) {
          const traitsDiv = document.createElement("div");
          traitsDiv.className = "codex-traits";
          for (const trait of disc.requiredTraits) {
            const badge = document.createElement("span");
            badge.className = "codex-trait-badge";
            const c = traitBadgeColor(trait);
            badge.style.background = c.bg;
            badge.style.borderColor = c.border;
            badge.style.color = c.color;
            badge.textContent = trait;
            traitsDiv.appendChild(badge);
          }
          entry.appendChild(traitsDiv);
        }

        // Times produced
        if (disc.timesProduced > 1) {
          const countDiv = document.createElement("div");
          countDiv.className = "codex-entry-count";
          countDiv.textContent = "produced " + disc.timesProduced + "x";
          entry.appendChild(countDiv);
        }
      } else {
        // Undiscovered entry
        entry.className = "codex-entry undiscovered";

        const hint = codexData.hints[arch.name];
        if (hint) {
          const hintDiv = document.createElement("div");
          hintDiv.className = "codex-entry-hint";
          hintDiv.textContent = hint.text;
          entry.appendChild(hintDiv);
        } else {
          const unknown = document.createElement("div");
          unknown.className = "codex-entry-unknown";
          unknown.textContent = "???";
          entry.appendChild(unknown);
        }
      }

      entries.appendChild(entry);
    }

    group.appendChild(entries);
    panel.appendChild(group);
  }

  updateCodexBtnCount();
}

function toggleCodex() {
  const overlay = document.getElementById("codexOverlay");
  const isOpen = overlay.classList.contains("open");
  if (isOpen) {
    overlay.classList.remove("open");
  } else {
    renderCodexPanel();
    overlay.classList.add("open");
  }
}

document.getElementById("codexBtn").addEventListener("click", toggleCodex);

document.getElementById("codexOverlay").addEventListener("click", function(e) {
  if (e.target === this) toggleCodex();
});

updateCodexBtnCount();

// ============================================================
// SOUND TOGGLE
// ============================================================

(function initSoundToggle() {
  const btn = document.getElementById("soundToggle");
  if (localStorage.getItem("tink-sound-muted")) {
    btn.classList.add("muted");
    btn.innerHTML = "&#x1f507;";
  }
  btn.addEventListener("click", () => {
    GameAudio.init();
    GameAudio.enabled = !GameAudio.enabled;
    if (GameAudio.enabled) {
      localStorage.removeItem("tink-sound-muted");
      btn.classList.remove("muted");
      btn.innerHTML = "&#x1f50a;";
    } else {
      localStorage.setItem("tink-sound-muted", "1");
      btn.classList.add("muted");
      btn.innerHTML = "&#x1f507;";
    }
  });
})();

// ============================================================
// INITIALIZATION
// ============================================================

function initGame(phase) {
  phase = phase || "wander";

  if (phase === "wander") {
    startRun();
    return;
  }

  // Weave phase initialization (called via startWeave or directly)
  startWeave([]);
}

// Escape to cancel drag or close codex
document.addEventListener("keydown", (e) => {
  if (e.key === "Escape") {
    if (wanderDraftOpen) {
      closeDraft();
    } else if (wanderShrineOpen) {
      closeShrineOverlay();
    } else if (document.getElementById("codexOverlay").classList.contains("open")) {
      toggleCodex();
    } else if (dragState) {
      cancelDrag();
    }
  }
});

// Prevent scrolling on touch devices during drag
document.addEventListener("touchmove", (e) => {
  if (dragState) e.preventDefault();
}, { passive: false });

// Start
initGame();
</script>

</body>
</html>
